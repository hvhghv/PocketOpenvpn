<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVPN: src/openvpn/argv.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVPN
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_92f13d409beef24f5ba1b81abfed1f1c.html">openvpn</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">argv.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="syshead_8h_source.html">syshead.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="argv_8h_source.html">argv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="integer_8h_source.html">integer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="env__set_8h_source.html">env_set.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="options_8h_source.html">options.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for argv.c:</div>
<div class="dyncontent">
<div class="center"><img src="argv_8c__incl.png" border="0" usemap="#src_2openvpn_2argv_8c" alt=""/></div>
<map name="src_2openvpn_2argv_8c" id="src_2openvpn_2argv_8c">
<area shape="rect" title=" " alt="" coords="1835,5,1967,32"/>
<area shape="rect" href="syshead_8h.html" title=" " alt="" coords="2088,528,2171,555"/>
<area shape="rect" href="argv_8h.html" title=" " alt="" coords="963,603,1021,629"/>
<area shape="rect" href="integer_8h.html" title=" " alt="" coords="165,528,237,555"/>
<area shape="rect" href="env__set_8h.html" title=" " alt="" coords="1099,528,1178,555"/>
<area shape="rect" href="options_8h.html" title=" " alt="" coords="1003,80,1077,107"/>
<area shape="rect" href="compat_8h.html" title=" " alt="" coords="2497,603,2573,629"/>
<area shape="rect" title=" " alt="" coords="1629,827,1704,853"/>
<area shape="rect" title=" " alt="" coords="1657,603,1741,629"/>
<area shape="rect" title=" " alt="" coords="2597,603,2685,629"/>
<area shape="rect" title=" " alt="" coords="1765,603,1843,629"/>
<area shape="rect" title=" " alt="" coords="1867,603,1954,629"/>
<area shape="rect" title=" " alt="" coords="1979,603,2061,629"/>
<area shape="rect" title=" " alt="" coords="2085,603,2163,629"/>
<area shape="rect" title=" " alt="" coords="2187,603,2261,629"/>
<area shape="rect" title=" " alt="" coords="2285,603,2363,629"/>
<area shape="rect" title=" " alt="" coords="2387,603,2472,629"/>
<area shape="rect" href="buffer_8h.html" title=" " alt="" coords="893,677,958,704"/>
<area shape="rect" href="openvpn_2basic_8h.html" title=" " alt="" coords="1184,827,1248,853"/>
<area shape="rect" href="openvpn_2error_8h.html" title=" " alt="" coords="897,752,956,779"/>
<area shape="rect" title=" " alt="" coords="989,827,1051,853"/>
<area shape="rect" title=" " alt="" coords="796,827,865,853"/>
<area shape="rect" href="errlevel_8h.html" title=" " alt="" coords="889,827,964,853"/>
<area shape="rect" href="common_8h.html" title=" " alt="" coords="667,603,749,629"/>
<area shape="rect" href="mtu_8h.html" title=" " alt="" coords="833,603,887,629"/>
<area shape="rect" href="route_8h.html" title=" " alt="" coords="1257,304,1319,331"/>
<area shape="rect" href="tun_8h.html" title=" " alt="" coords="1225,379,1276,405"/>
<area shape="rect" href="socket_8h.html" title=" " alt="" coords="568,304,640,331"/>
<area shape="rect" href="proxy_8h.html" title=" " alt="" coords="333,379,397,405"/>
<area shape="rect" href="plugin_8h.html" title=" " alt="" coords="715,155,781,181"/>
<area shape="rect" href="manage_8h.html" title=" " alt="" coords="953,155,1031,181"/>
<area shape="rect" href="comp_8h.html" title=" " alt="" coords="1055,155,1121,181"/>
<area shape="rect" href="pushlist_8h.html" title=" " alt="" coords="1206,155,1285,181"/>
<area shape="rect" href="clinat_8h.html" title=" " alt="" coords="93,304,157,331"/>
<area shape="rect" href="crypto__backend_8h.html" title=" " alt="" coords="1456,603,1581,629"/>
<area shape="rect" href="misc_8h.html" title=" " alt="" coords="717,453,779,480"/>
<area shape="rect" href="networking_8h.html" title=" " alt="" coords="1699,453,1795,480"/>
<area shape="rect" title=" " alt="" coords="1304,603,1381,629"/>
<area shape="rect" title=" " alt="" coords="1197,453,1304,480"/>
<area shape="rect" title=" " alt="" coords="1328,453,1411,480"/>
<area shape="rect" title=" " alt="" coords="1435,453,1522,480"/>
<area shape="rect" href="win32_8h.html" title=" " alt="" coords="957,528,1024,555"/>
<area shape="rect" href="event_8h.html" title=" " alt="" coords="854,453,919,480"/>
<area shape="rect" href="proto_8h.html" title=" " alt="" coords="718,528,781,555"/>
<area shape="rect" href="ring__buffer_8h.html" title=" " alt="" coords="1971,528,2064,555"/>
<area shape="rect" href="socks_8h.html" title=" " alt="" coords="422,379,490,405"/>
<area shape="rect" href="ssl__verify__openssl_8h.html" title=" " alt="" coords="755,229,896,256"/>
<area shape="rect" href="openvpn-plugin_8h.html" title=" " alt="" coords="611,229,731,256"/>
<area shape="rect" href="mroute_8h.html" title=" " alt="" coords="1073,229,1146,256"/>
<area shape="rect" href="crypto__openssl_8h.html" title=" " alt="" coords="1507,677,1629,704"/>
</map>
</div>
</div>
<p><a href="argv_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5769e6e1fb42122a6c9fa498cca6bd4a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="argv_8c.html#a5769e6e1fb42122a6c9fa498cca6bd4a">argv_extend</a> (struct <a class="el" href="structargv.html">argv</a> *a, const size_t newcap)</td></tr>
<tr class="memdesc:a5769e6e1fb42122a6c9fa498cca6bd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the list of arguments struct argv can carry.  <a href="argv_8c.html#a5769e6e1fb42122a6c9fa498cca6bd4a">More...</a><br /></td></tr>
<tr class="separator:a5769e6e1fb42122a6c9fa498cca6bd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64672618be907bdfd299f2fee4cbfba8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="argv_8c.html#a64672618be907bdfd299f2fee4cbfba8">argv_init</a> (struct <a class="el" href="structargv.html">argv</a> *a)</td></tr>
<tr class="memdesc:a64672618be907bdfd299f2fee4cbfba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise an already allocated struct argv.  <a href="argv_8c.html#a64672618be907bdfd299f2fee4cbfba8">More...</a><br /></td></tr>
<tr class="separator:a64672618be907bdfd299f2fee4cbfba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03da330eccab6d3239253b774a92d4d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structargv.html">argv</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="argv_8c.html#ae03da330eccab6d3239253b774a92d4d">argv_new</a> (void)</td></tr>
<tr class="memdesc:ae03da330eccab6d3239253b774a92d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new struct argv and ensures it is initialised.  <a href="argv_8c.html#ae03da330eccab6d3239253b774a92d4d">More...</a><br /></td></tr>
<tr class="separator:ae03da330eccab6d3239253b774a92d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8563bed2ee30eda7125eee7bdb9ab4eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="argv_8c.html#a8563bed2ee30eda7125eee7bdb9ab4eb">argv_free</a> (struct <a class="el" href="structargv.html">argv</a> *a)</td></tr>
<tr class="memdesc:a8563bed2ee30eda7125eee7bdb9ab4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all memory allocations allocated by the struct argv related functions.  <a href="argv_8c.html#a8563bed2ee30eda7125eee7bdb9ab4eb">More...</a><br /></td></tr>
<tr class="separator:a8563bed2ee30eda7125eee7bdb9ab4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eeef6841700aa0a4e4e426d1d13dc45"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="argv_8c.html#a5eeef6841700aa0a4e4e426d1d13dc45">argv_reset</a> (struct <a class="el" href="structargv.html">argv</a> *a)</td></tr>
<tr class="memdesc:a5eeef6841700aa0a4e4e426d1d13dc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the struct argv to an initial state.  <a href="argv_8c.html#a5eeef6841700aa0a4e4e426d1d13dc45">More...</a><br /></td></tr>
<tr class="separator:a5eeef6841700aa0a4e4e426d1d13dc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cf76571ea8d38085ab5301bd8ea649"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="argv_8c.html#aa9cf76571ea8d38085ab5301bd8ea649">argv_grow</a> (struct <a class="el" href="structargv.html">argv</a> *a, const size_t add)</td></tr>
<tr class="memdesc:aa9cf76571ea8d38085ab5301bd8ea649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends an existing struct argv to carry minimum 'add' number of new arguments.  <a href="argv_8c.html#aa9cf76571ea8d38085ab5301bd8ea649">More...</a><br /></td></tr>
<tr class="separator:aa9cf76571ea8d38085ab5301bd8ea649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c2de84fb8896160c79a5289663189f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="argv_8c.html#ab4c2de84fb8896160c79a5289663189f">argv_append</a> (struct <a class="el" href="structargv.html">argv</a> *a, char *str)</td></tr>
<tr class="memdesc:ab4c2de84fb8896160c79a5289663189f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a string to to the list of arguments stored in a struct argv This will ensure the list size in struct argv has the needed capacity to store the value.  <a href="argv_8c.html#ab4c2de84fb8896160c79a5289663189f">More...</a><br /></td></tr>
<tr class="separator:ab4c2de84fb8896160c79a5289663189f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e910847428fa3d0967f1935d74a1e5"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structargv.html">argv</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="argv_8c.html#a46e910847428fa3d0967f1935d74a1e5">argv_clone</a> (const struct <a class="el" href="structargv.html">argv</a> *<a class="el" href="compat-lz4_8h.html#a0211201f992ec3f0b641c9ceff5f837a">source</a>, const size_t headroom)</td></tr>
<tr class="memdesc:a46e910847428fa3d0967f1935d74a1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones a struct argv with all the contents to a new allocated struct argv.  <a href="argv_8c.html#a46e910847428fa3d0967f1935d74a1e5">More...</a><br /></td></tr>
<tr class="separator:a46e910847428fa3d0967f1935d74a1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebaf95471651931a3703e5441f155675"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structargv.html">argv</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="argv_8c.html#aebaf95471651931a3703e5441f155675">argv_insert_head</a> (const struct <a class="el" href="structargv.html">argv</a> *a, const char *head)</td></tr>
<tr class="memdesc:aebaf95471651931a3703e5441f155675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an argument string in front of all other argument slots.  <a href="argv_8c.html#aebaf95471651931a3703e5441f155675">More...</a><br /></td></tr>
<tr class="separator:aebaf95471651931a3703e5441f155675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969eb3c616318512e53d20ec4990dcc2"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="argv_8c.html#a969eb3c616318512e53d20ec4990dcc2">argv_str</a> (const struct <a class="el" href="structargv.html">argv</a> *a, struct <a class="el" href="structgc__arena.html">gc_arena</a> *gc, const unsigned int flags)</td></tr>
<tr class="memdesc:a969eb3c616318512e53d20ec4990dcc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a single string with all the arguments in a struct argv concatenated.  <a href="argv_8c.html#a969eb3c616318512e53d20ec4990dcc2">More...</a><br /></td></tr>
<tr class="separator:a969eb3c616318512e53d20ec4990dcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d63823a8aeddf605a2e4a4a420e1dd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="argv_8c.html#a4d63823a8aeddf605a2e4a4a420e1dd4">argv_msg</a> (const int msglev, const struct <a class="el" href="structargv.html">argv</a> *a)</td></tr>
<tr class="memdesc:a4d63823a8aeddf605a2e4a4a420e1dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the arguments stored in a struct argv via the <a class="el" href="openvpn_2error_8h.html#a3ac39702968675a6552a43d7c68bf7f9">msg()</a> command.  <a href="argv_8c.html#a4d63823a8aeddf605a2e4a4a420e1dd4">More...</a><br /></td></tr>
<tr class="separator:a4d63823a8aeddf605a2e4a4a420e1dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d2724394ee9bc29ac5d5ac2c1da102"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="argv_8c.html#a58d2724394ee9bc29ac5d5ac2c1da102">argv_msg_prefix</a> (const int msglev, const struct <a class="el" href="structargv.html">argv</a> *a, const char *prefix)</td></tr>
<tr class="memdesc:a58d2724394ee9bc29ac5d5ac2c1da102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="argv_8c.html#a4d63823a8aeddf605a2e4a4a420e1dd4" title="Write the arguments stored in a struct argv via the msg() command.">argv_msg()</a> but prefixes the messages being written with a given string.  <a href="argv_8c.html#a58d2724394ee9bc29ac5d5ac2c1da102">More...</a><br /></td></tr>
<tr class="separator:a58d2724394ee9bc29ac5d5ac2c1da102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fc3237fa205a5371c7d2df0583f908"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="argv_8c.html#ad7fc3237fa205a5371c7d2df0583f908">argv_prep_format</a> (const char *format, const char delim, size_t *count, struct <a class="el" href="structgc__arena.html">gc_arena</a> *gc)</td></tr>
<tr class="memdesc:ad7fc3237fa205a5371c7d2df0583f908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares argv format string for further processing.  <a href="argv_8c.html#ad7fc3237fa205a5371c7d2df0583f908">More...</a><br /></td></tr>
<tr class="separator:ad7fc3237fa205a5371c7d2df0583f908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d46f76ffdc1b77e783cce1953e7dd59"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="argv_8c.html#a9d46f76ffdc1b77e783cce1953e7dd59">argv_printf_arglist</a> (struct <a class="el" href="structargv.html">argv</a> *argres, const char *format, va_list arglist)</td></tr>
<tr class="memdesc:a9d46f76ffdc1b77e783cce1953e7dd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a struct argv based on a format string.  <a href="argv_8c.html#a9d46f76ffdc1b77e783cce1953e7dd59">More...</a><br /></td></tr>
<tr class="separator:a9d46f76ffdc1b77e783cce1953e7dd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8c504c4703e6e88c52463da877c8a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="argv_8c.html#acb8c504c4703e6e88c52463da877c8a8">argv_printf</a> (struct <a class="el" href="structargv.html">argv</a> *argres, const char *format,...)</td></tr>
<tr class="memdesc:acb8c504c4703e6e88c52463da877c8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">printf() variant which populates a struct argv.  <a href="argv_8c.html#acb8c504c4703e6e88c52463da877c8a8">More...</a><br /></td></tr>
<tr class="separator:acb8c504c4703e6e88c52463da877c8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62a50a5c6133eaea0422cee6ba840cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="argv_8c.html#ad62a50a5c6133eaea0422cee6ba840cf">argv_printf_cat</a> (struct <a class="el" href="structargv.html">argv</a> *argres, const char *format,...)</td></tr>
<tr class="memdesc:ad62a50a5c6133eaea0422cee6ba840cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">printf() inspired argv concatenation.  <a href="argv_8c.html#ad62a50a5c6133eaea0422cee6ba840cf">More...</a><br /></td></tr>
<tr class="separator:ad62a50a5c6133eaea0422cee6ba840cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774ef043771e6da40b48dde907f1e205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="argv_8c.html#a774ef043771e6da40b48dde907f1e205">argv_parse_cmd</a> (struct <a class="el" href="structargv.html">argv</a> *argres, const char *cmdstr)</td></tr>
<tr class="memdesc:a774ef043771e6da40b48dde907f1e205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a command string, tokenizes it and puts each element into a separate struct argv argument slot.  <a href="argv_8c.html#a774ef043771e6da40b48dde907f1e205">More...</a><br /></td></tr>
<tr class="separator:a774ef043771e6da40b48dde907f1e205"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab4c2de84fb8896160c79a5289663189f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c2de84fb8896160c79a5289663189f">&#9670;&nbsp;</a></span>argv_append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void argv_append </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structargv.html">argv</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a string to to the list of arguments stored in a struct argv This will ensure the list size in struct argv has the needed capacity to store the value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*a</td><td>struct argv where to append the new string value </td></tr>
    <tr><td class="paramname">&lt;em&gt;str</td><td>Pointer to string to append. The provided string *MUST have been malloc()ed or NULL. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="argv_8c_source.html#l00160">160</a> of file <a class="el" href="argv_8c_source.html">argv.c</a>.</p>

<p class="reference">References <a class="el" href="argv_8h_source.html#l00038">argv::argc</a>, <a class="el" href="argv_8h_source.html#l00039">argv::argv</a>, and <a class="el" href="argv_8c_source.html#l00143">argv_grow()</a>.</p>

<p class="reference">Referenced by <a class="el" href="argv_8c_source.html#l00182">argv_clone()</a>, <a class="el" href="argv_8c_source.html#l00485">argv_parse_cmd()</a>, and <a class="el" href="argv_8c_source.html#l00351">argv_printf_arglist()</a>.</p>

</div>
</div>
<a id="a46e910847428fa3d0967f1935d74a1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e910847428fa3d0967f1935d74a1e5">&#9670;&nbsp;</a></span>argv_clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structargv.html">argv</a> argv_clone </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structargv.html">argv</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>headroom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clones a struct argv with all the contents to a new allocated struct argv. </p>
<p>If 'headroom' is larger than 0, it will create a head-room in front of the values being copied from the source input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*source</td><td>Valid pointer to the source struct argv to clone. It may be NULL. </td></tr>
    <tr><td class="paramname">headroom</td><td>Number of slots to leave empty in front of the slots copied from the source.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a new struct argv containing a copy of the source struct argv, with the given headroom in front of the copy. </dd></dl>

<p class="definition">Definition at line <a class="el" href="argv_8c_source.html#l00182">182</a> of file <a class="el" href="argv_8c_source.html">argv.c</a>.</p>

<p class="reference">References <a class="el" href="argv_8c_source.html#l00160">argv_append()</a>, <a class="el" href="argv_8c_source.html#l00074">argv_init()</a>, <a class="el" href="argv_8h_source.html#l00036">argv::gc</a>, <a class="el" href="compat-lz4_8h_source.html#l00688">source</a>, and <a class="el" href="buffer_8c_source.html#l00665">string_alloc()</a>.</p>

<p class="reference">Referenced by <a class="el" href="argv_8c_source.html#l00210">argv_insert_head()</a>.</p>

</div>
</div>
<a id="a5769e6e1fb42122a6c9fa498cca6bd4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5769e6e1fb42122a6c9fa498cca6bd4a">&#9670;&nbsp;</a></span>argv_extend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void argv_extend </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structargv.html">argv</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>newcap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the list of arguments struct argv can carry. </p>
<p>This resize operation will only increase the size, never decrease the size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*a</td><td>Valid pointer to a struct argv to resize </td></tr>
    <tr><td class="paramname">newcap</td><td>size_t with the new size of the argument list. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="argv_8c_source.html#l00051">51</a> of file <a class="el" href="argv_8c_source.html">argv.c</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l01081">ALLOC_ARRAY_CLEAR_GC</a>, <a class="el" href="argv_8h_source.html#l00038">argv::argc</a>, <a class="el" href="argv_8h_source.html#l00039">argv::argv</a>, <a class="el" href="argv_8h_source.html#l00037">argv::capacity</a>, and <a class="el" href="argv_8h_source.html#l00036">argv::gc</a>.</p>

<p class="reference">Referenced by <a class="el" href="argv_8c_source.html#l00143">argv_grow()</a>, and <a class="el" href="argv_8c_source.html#l00074">argv_init()</a>.</p>

</div>
</div>
<a id="a8563bed2ee30eda7125eee7bdb9ab4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8563bed2ee30eda7125eee7bdb9ab4eb">&#9670;&nbsp;</a></span>argv_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void argv_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structargv.html">argv</a> *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees all memory allocations allocated by the struct argv related functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*a</td><td>Valid pointer to a struct argv to release memory from </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="argv_8c_source.html#l00104">104</a> of file <a class="el" href="argv_8c_source.html">argv.c</a>.</p>

<p class="reference">References <a class="el" href="argv_8h_source.html#l00036">argv::gc</a>, and <a class="el" href="buffer_8h_source.html#l01032">gc_free()</a>.</p>

<p class="reference">Referenced by <a class="el" href="route_8c_source.html#l01566">add_route()</a>, <a class="el" href="route_8c_source.html#l01877">add_route_ipv6()</a>, <a class="el" href="test__argv_8c_source.html#l00214">argv_insert_head__empty_argv__head_only()</a>, <a class="el" href="test__argv_8c_source.html#l00228">argv_insert_head__non_empty_argv__head_added()</a>, <a class="el" href="test__argv_8c_source.html#l00154">argv_parse_cmd__command_and_extra_options__argc_correct()</a>, <a class="el" href="test__argv_8c_source.html#l00143">argv_parse_cmd__command_string__argc_correct()</a>, <a class="el" href="test__argv_8c_source.html#l00081">argv_printf__combined_path_with_spaces__argc_correct()</a>, <a class="el" href="test__argv_8c_source.html#l00058">argv_printf__embedded_format_directive__replaced_in_output()</a>, <a class="el" href="test__argv_8c_source.html#l00098">argv_printf__empty_parameter__argc_correct()</a>, <a class="el" href="test__argv_8c_source.html#l00070">argv_printf__group_sep_in_arg__fail_no_ouput()</a>, <a class="el" href="test__argv_8c_source.html#l00121">argv_printf__long_args__data_correct()</a>, <a class="el" href="test__argv_8c_source.html#l00035">argv_printf__multiple_spaces_in_format__parsed_as_one()</a>, <a class="el" href="test__argv_8c_source.html#l00046">argv_printf_cat__multiple_spaces_in_format__parsed_as_one()</a>, <a class="el" href="test__argv_8c_source.html#l00166">argv_printf_cat__used_twice__argc_correct()</a>, <a class="el" href="test__argv_8c_source.html#l00179">argv_str__empty_argv__empty_output()</a>, <a class="el" href="test__argv_8c_source.html#l00193">argv_str__multiple_argv__correct_output()</a>, <a class="el" href="options_8c_source.html#l03400">check_cmd_access()</a>, <a class="el" href="route_8c_source.html#l02159">delete_route()</a>, <a class="el" href="route_8c_source.html#l02353">delete_route_ipv6()</a>, <a class="el" href="tun_8c_source.html#l01209">do_ifconfig_ipv4()</a>, <a class="el" href="tun_8c_source.html#l01011">do_ifconfig_ipv6()</a>, <a class="el" href="init_8c_source.html#l01696">do_route()</a>, <a class="el" href="tun_8c_source.html#l05230">ipconfig_register_dns()</a>, <a class="el" href="multi_8c_source.html#l00096">learn_address_script()</a>, <a class="el" href="socket_8c_source.html#l02469">link_socket_connection_initiated()</a>, <a class="el" href="multi_8c_source.html#l02067">multi_client_connect_call_plugin_v1()</a>, <a class="el" href="multi_8c_source.html#l02259">multi_client_connect_call_script()</a>, <a class="el" href="multi_8c_source.html#l00575">multi_client_disconnect_script()</a>, <a class="el" href="tun_8c_source.html#l06745">netsh_delete_address_dns()</a>, <a class="el" href="tun_8c_source.html#l05556">netsh_enable_dhcp()</a>, <a class="el" href="tun_8c_source.html#l05484">netsh_ifconfig()</a>, <a class="el" href="tun_8c_source.html#l05385">netsh_ifconfig_options()</a>, <a class="el" href="tun_8c_source.html#l05347">netsh_set_dns6_servers()</a>, <a class="el" href="plugin_8c_source.html#l00537">plugin_call_item()</a>, <a class="el" href="init_8c_source.html#l00105">run_up_down()</a>, <a class="el" href="lladdr_8c_source.html#l00019">set_lladdr()</a>, <a class="el" href="tls__crypt_8c_source.html#l00514">tls_crypt_v2_verify_metadata()</a>, <a class="el" href="ssl__verify_8c_source.html#l00549">verify_cert_call_command()</a>, <a class="el" href="ssl__verify_8c_source.html#l00481">verify_cert_call_plugin()</a>, and <a class="el" href="ssl__verify_8c_source.html#l01104">verify_user_pass_script()</a>.</p>

</div>
</div>
<a id="aa9cf76571ea8d38085ab5301bd8ea649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9cf76571ea8d38085ab5301bd8ea649">&#9670;&nbsp;</a></span>argv_grow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void argv_grow </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structargv.html">argv</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>add</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extends an existing struct argv to carry minimum 'add' number of new arguments. </p>
<p>This builds on <a class="el" href="argv_8c.html#a5769e6e1fb42122a6c9fa498cca6bd4a" title="Resizes the list of arguments struct argv can carry.">argv_extend()</a>, which ensures the new size will only be higher than the current capacity.</p>
<p>The new size is also calculated based on the result of <a class="el" href="integer_8h.html#a04fc4fec46e44aab818d512ebefe304e">adjust_power_of_2()</a>. This approach ensures that the list does grow bulks and only when the current limit is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*a</td><td>Valid pointer to the struct argv to extend </td></tr>
    <tr><td class="paramname">add</td><td>size_t with the number of elements to add. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="argv_8c_source.html#l00143">143</a> of file <a class="el" href="argv_8c_source.html">argv.c</a>.</p>

<p class="reference">References <a class="el" href="integer_8h_source.html#l00136">adjust_power_of_2()</a>, <a class="el" href="argv_8h_source.html#l00038">argv::argc</a>, <a class="el" href="argv_8c_source.html#l00051">argv_extend()</a>, and <a class="el" href="openvpn_2error_8h_source.html#l00218">ASSERT</a>.</p>

<p class="reference">Referenced by <a class="el" href="argv_8c_source.html#l00160">argv_append()</a>.</p>

</div>
</div>
<a id="a64672618be907bdfd299f2fee4cbfba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64672618be907bdfd299f2fee4cbfba8">&#9670;&nbsp;</a></span>argv_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void argv_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structargv.html">argv</a> *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialise an already allocated struct argv. </p>
<p>It is expected that the input argument is a valid pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*a</td><td>Pointer to a struct argv to initialise </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="argv_8c_source.html#l00074">74</a> of file <a class="el" href="argv_8c_source.html">argv.c</a>.</p>

<p class="reference">References <a class="el" href="argv_8h_source.html#l00038">argv::argc</a>, <a class="el" href="argv_8h_source.html#l00039">argv::argv</a>, <a class="el" href="argv_8c_source.html#l00051">argv_extend()</a>, <a class="el" href="argv_8h_source.html#l00037">argv::capacity</a>, <a class="el" href="argv_8h_source.html#l00036">argv::gc</a>, and <a class="el" href="buffer_8h_source.html#l01024">gc_new()</a>.</p>

<p class="reference">Referenced by <a class="el" href="argv_8c_source.html#l00182">argv_clone()</a>, and <a class="el" href="argv_8c_source.html#l00090">argv_new()</a>.</p>

</div>
</div>
<a id="aebaf95471651931a3703e5441f155675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebaf95471651931a3703e5441f155675">&#9670;&nbsp;</a></span>argv_insert_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structargv.html">argv</a> argv_insert_head </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structargv.html">argv</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>head</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts an argument string in front of all other argument slots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*a</td><td>Valid pointer to the struct argv to insert the argument into </td></tr>
    <tr><td class="paramname">*head</td><td>Pointer to the char * string with the argument to insert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a new struct argv with the inserted argument in front </dd></dl>

<p class="definition">Definition at line <a class="el" href="argv_8c_source.html#l00210">210</a> of file <a class="el" href="argv_8c_source.html">argv.c</a>.</p>

<p class="reference">References <a class="el" href="argv_8c_source.html#l00182">argv_clone()</a>, and <a class="el" href="buffer_8c_source.html#l00665">string_alloc()</a>.</p>

<p class="reference">Referenced by <a class="el" href="test__argv_8c_source.html#l00214">argv_insert_head__empty_argv__head_only()</a>, <a class="el" href="test__argv_8c_source.html#l00228">argv_insert_head__non_empty_argv__head_added()</a>, and <a class="el" href="plugin_8c_source.html#l00537">plugin_call_item()</a>.</p>

</div>
</div>
<a id="a4d63823a8aeddf605a2e4a4a420e1dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d63823a8aeddf605a2e4a4a420e1dd4">&#9670;&nbsp;</a></span>argv_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void argv_msg </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>msglev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structargv.html">argv</a> *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the arguments stored in a struct argv via the <a class="el" href="openvpn_2error_8h.html#a3ac39702968675a6552a43d7c68bf7f9">msg()</a> command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msglev</td><td>Integer with the message level used by <a class="el" href="openvpn_2error_8h.html#a3ac39702968675a6552a43d7c68bf7f9">msg()</a>. </td></tr>
    <tr><td class="paramname">*a</td><td>Valid pointer to the struct argv with the arguments to write. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="argv_8c_source.html#l00245">245</a> of file <a class="el" href="argv_8c_source.html">argv.c</a>.</p>

<p class="reference">References <a class="el" href="argv_8c_source.html#l00233">argv_str()</a>, <a class="el" href="buffer_8h_source.html#l01032">gc_free()</a>, <a class="el" href="buffer_8h_source.html#l01024">gc_new()</a>, and <a class="el" href="openvpn_2error_8h_source.html#l00170">msg</a>.</p>

<p class="reference">Referenced by <a class="el" href="route_8c_source.html#l01566">add_route()</a>, <a class="el" href="route_8c_source.html#l01877">add_route_ipv6()</a>, <a class="el" href="route_8c_source.html#l02159">delete_route()</a>, <a class="el" href="route_8c_source.html#l02353">delete_route_ipv6()</a>, <a class="el" href="tun_8c_source.html#l01209">do_ifconfig_ipv4()</a>, <a class="el" href="tun_8c_source.html#l01011">do_ifconfig_ipv6()</a>, <a class="el" href="tun_8c_source.html#l05230">ipconfig_register_dns()</a>, <a class="el" href="init_8c_source.html#l00105">run_up_down()</a>, and <a class="el" href="lladdr_8c_source.html#l00019">set_lladdr()</a>.</p>

</div>
</div>
<a id="a58d2724394ee9bc29ac5d5ac2c1da102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d2724394ee9bc29ac5d5ac2c1da102">&#9670;&nbsp;</a></span>argv_msg_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void argv_msg_prefix </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>msglev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structargv.html">argv</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="argv_8c.html#a4d63823a8aeddf605a2e4a4a420e1dd4" title="Write the arguments stored in a struct argv via the msg() command.">argv_msg()</a> but prefixes the messages being written with a given string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msglev</td><td>Integer with the message level used by <a class="el" href="openvpn_2error_8h.html#a3ac39702968675a6552a43d7c68bf7f9">msg()</a>. </td></tr>
    <tr><td class="paramname">*a</td><td>Valid pointer to the struct argv with the arguments to write </td></tr>
    <tr><td class="paramname">*prefix</td><td>Valid char * pointer to the prefix string </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="argv_8c_source.html#l00262">262</a> of file <a class="el" href="argv_8c_source.html">argv.c</a>.</p>

<p class="reference">References <a class="el" href="argv_8c_source.html#l00233">argv_str()</a>, <a class="el" href="buffer_8h_source.html#l01032">gc_free()</a>, <a class="el" href="buffer_8h_source.html#l01024">gc_new()</a>, and <a class="el" href="openvpn_2error_8h_source.html#l00170">msg</a>.</p>

<p class="reference">Referenced by <a class="el" href="tun_8c_source.html#l05209">netsh_command()</a>, <a class="el" href="tls__crypt_8c_source.html#l00514">tls_crypt_v2_verify_metadata()</a>, and <a class="el" href="ssl__verify_8c_source.html#l00549">verify_cert_call_command()</a>.</p>

</div>
</div>
<a id="ae03da330eccab6d3239253b774a92d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03da330eccab6d3239253b774a92d4d">&#9670;&nbsp;</a></span>argv_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structargv.html">argv</a> argv_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new struct argv and ensures it is initialised. </p>
<p>Note that it does not return a pointer, but a struct argv directly.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns an initialised and empty struct argv. </dd></dl>

<p class="definition">Definition at line <a class="el" href="argv_8c_source.html#l00090">90</a> of file <a class="el" href="argv_8c_source.html">argv.c</a>.</p>

<p class="reference">References <a class="el" href="argv_8c_source.html#l00074">argv_init()</a>.</p>

<p class="reference">Referenced by <a class="el" href="route_8c_source.html#l01566">add_route()</a>, <a class="el" href="route_8c_source.html#l01877">add_route_ipv6()</a>, <a class="el" href="test__argv_8c_source.html#l00214">argv_insert_head__empty_argv__head_only()</a>, <a class="el" href="test__argv_8c_source.html#l00228">argv_insert_head__non_empty_argv__head_added()</a>, <a class="el" href="test__argv_8c_source.html#l00154">argv_parse_cmd__command_and_extra_options__argc_correct()</a>, <a class="el" href="test__argv_8c_source.html#l00143">argv_parse_cmd__command_string__argc_correct()</a>, <a class="el" href="test__argv_8c_source.html#l00081">argv_printf__combined_path_with_spaces__argc_correct()</a>, <a class="el" href="test__argv_8c_source.html#l00058">argv_printf__embedded_format_directive__replaced_in_output()</a>, <a class="el" href="test__argv_8c_source.html#l00098">argv_printf__empty_parameter__argc_correct()</a>, <a class="el" href="test__argv_8c_source.html#l00070">argv_printf__group_sep_in_arg__fail_no_ouput()</a>, <a class="el" href="test__argv_8c_source.html#l00121">argv_printf__long_args__data_correct()</a>, <a class="el" href="test__argv_8c_source.html#l00035">argv_printf__multiple_spaces_in_format__parsed_as_one()</a>, <a class="el" href="test__argv_8c_source.html#l00046">argv_printf_cat__multiple_spaces_in_format__parsed_as_one()</a>, <a class="el" href="test__argv_8c_source.html#l00166">argv_printf_cat__used_twice__argc_correct()</a>, <a class="el" href="test__argv_8c_source.html#l00179">argv_str__empty_argv__empty_output()</a>, <a class="el" href="test__argv_8c_source.html#l00193">argv_str__multiple_argv__correct_output()</a>, <a class="el" href="options_8c_source.html#l03400">check_cmd_access()</a>, <a class="el" href="route_8c_source.html#l02159">delete_route()</a>, <a class="el" href="route_8c_source.html#l02353">delete_route_ipv6()</a>, <a class="el" href="tun_8c_source.html#l01209">do_ifconfig_ipv4()</a>, <a class="el" href="tun_8c_source.html#l01011">do_ifconfig_ipv6()</a>, <a class="el" href="init_8c_source.html#l01696">do_route()</a>, <a class="el" href="tun_8c_source.html#l05230">ipconfig_register_dns()</a>, <a class="el" href="multi_8c_source.html#l00096">learn_address_script()</a>, <a class="el" href="socket_8c_source.html#l02469">link_socket_connection_initiated()</a>, <a class="el" href="multi_8c_source.html#l02067">multi_client_connect_call_plugin_v1()</a>, <a class="el" href="multi_8c_source.html#l02259">multi_client_connect_call_script()</a>, <a class="el" href="multi_8c_source.html#l00575">multi_client_disconnect_script()</a>, <a class="el" href="tun_8c_source.html#l06745">netsh_delete_address_dns()</a>, <a class="el" href="tun_8c_source.html#l05556">netsh_enable_dhcp()</a>, <a class="el" href="tun_8c_source.html#l05484">netsh_ifconfig()</a>, <a class="el" href="tun_8c_source.html#l05385">netsh_ifconfig_options()</a>, <a class="el" href="tun_8c_source.html#l05347">netsh_set_dns6_servers()</a>, <a class="el" href="init_8c_source.html#l00105">run_up_down()</a>, <a class="el" href="lladdr_8c_source.html#l00019">set_lladdr()</a>, <a class="el" href="tls__crypt_8c_source.html#l00514">tls_crypt_v2_verify_metadata()</a>, <a class="el" href="ssl__verify_8c_source.html#l00549">verify_cert_call_command()</a>, <a class="el" href="ssl__verify_8c_source.html#l00481">verify_cert_call_plugin()</a>, and <a class="el" href="ssl__verify_8c_source.html#l01104">verify_user_pass_script()</a>.</p>

</div>
</div>
<a id="a774ef043771e6da40b48dde907f1e205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774ef043771e6da40b48dde907f1e205">&#9670;&nbsp;</a></span>argv_parse_cmd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void argv_parse_cmd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structargv.html">argv</a> *&#160;</td>
          <td class="paramname"><em>argres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmdstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a command string, tokenizes it and puts each element into a separate struct argv argument slot. </p>
<p>@params *argres Valid pointer to a struct argv where the parsed result will be found. @params *cmdstr Char * based string to parse </p>

<p class="definition">Definition at line <a class="el" href="argv_8c_source.html#l00485">485</a> of file <a class="el" href="argv_8c_source.html">argv.c</a>.</p>

<p class="reference">References <a class="el" href="argv_8c_source.html#l00160">argv_append()</a>, <a class="el" href="argv_8c_source.html#l00116">argv_reset()</a>, <a class="el" href="errlevel_8h_source.html#l00145">D_ARGV_PARSE_CMD</a>, <a class="el" href="argv_8h_source.html#l00036">argv::gc</a>, <a class="el" href="options_8h_source.html#l00051">MAX_PARMS</a>, <a class="el" href="options_8c_source.html#l04497">parse_line()</a>, and <a class="el" href="buffer_8c_source.html#l00665">string_alloc()</a>.</p>

<p class="reference">Referenced by <a class="el" href="test__argv_8c_source.html#l00154">argv_parse_cmd__command_and_extra_options__argc_correct()</a>, <a class="el" href="test__argv_8c_source.html#l00143">argv_parse_cmd__command_string__argc_correct()</a>, <a class="el" href="options_8c_source.html#l03400">check_cmd_access()</a>, <a class="el" href="init_8c_source.html#l01696">do_route()</a>, <a class="el" href="socket_8c_source.html#l02453">ipchange_fmt()</a>, <a class="el" href="multi_8c_source.html#l00096">learn_address_script()</a>, <a class="el" href="multi_8c_source.html#l02259">multi_client_connect_call_script()</a>, <a class="el" href="multi_8c_source.html#l00575">multi_client_disconnect_script()</a>, <a class="el" href="init_8c_source.html#l00105">run_up_down()</a>, <a class="el" href="tls__crypt_8c_source.html#l00514">tls_crypt_v2_verify_metadata()</a>, <a class="el" href="ssl__verify_8c_source.html#l00549">verify_cert_call_command()</a>, and <a class="el" href="ssl__verify_8c_source.html#l01104">verify_user_pass_script()</a>.</p>

</div>
</div>
<a id="ad7fc3237fa205a5371c7d2df0583f908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fc3237fa205a5371c7d2df0583f908">&#9670;&nbsp;</a></span>argv_prep_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char* argv_prep_format </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structgc__arena.html">gc_arena</a> *&#160;</td>
          <td class="paramname"><em>gc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepares argv format string for further processing. </p>
<p>Individual argument must be separated by space. Ignores leading and trailing spaces. Consecutive spaces count as one. Returns prepared format string, with space replaced by delim and adds the number of arguments to the count parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*format</td><td>Pointer to a the format string to process </td></tr>
    <tr><td class="paramname">delim</td><td>Char with the delimiter to use </td></tr>
    <tr><td class="paramname">*count</td><td>size_t pointer used to return the number of tokens (argument slots) found in the format string. </td></tr>
    <tr><td class="paramname">*gc</td><td>Pointer to a <a class="el" href="structgc__arena.html" title="Garbage collection arena used to keep track of dynamically allocated memory.">gc_arena</a> managed buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a parsed format string (char *), together with the number of tokens parts found (via *count). The result string is allocated within the <a class="el" href="structgc__arena.html" title="Garbage collection arena used to keep track of dynamically allocated memory.">gc_arena</a> managed buffer. If the <a class="el" href="structgc__arena.html" title="Garbage collection arena used to keep track of dynamically allocated memory.">gc_arena</a> pointer is NULL, the returned string must be explicitly free()d to avoid memory leaks. </dd></dl>

<p class="definition">Definition at line <a class="el" href="argv_8c_source.html#l00290">290</a> of file <a class="el" href="argv_8c_source.html">argv.c</a>.</p>

<p class="reference">References <a class="el" href="http-client_8py_source.html#l00006">http-client::f</a>, and <a class="el" href="buffer_8c_source.html#l00385">gc_malloc()</a>.</p>

<p class="reference">Referenced by <a class="el" href="argv_8c_source.html#l00351">argv_printf_arglist()</a>.</p>

</div>
</div>
<a id="acb8c504c4703e6e88c52463da877c8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8c504c4703e6e88c52463da877c8a8">&#9670;&nbsp;</a></span>argv_printf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool argv_printf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structargv.html">argv</a> *&#160;</td>
          <td class="paramname"><em>argres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>printf() variant which populates a struct argv. </p>
<p>It processes the format string with the provided arguments. For each space separator found in the format string, a new argument will be added to the resulting struct argv.</p>
<p>This will always reset and ensure the result is based on a pristine struct argv.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*argres</td><td>Valid pointer to a struct argv where the result will be put. </td></tr>
    <tr><td class="paramname">*format</td><td>printf() compliant (char *) format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the parsing was successful. See <a class="el" href="argv_8c.html#a9d46f76ffdc1b77e783cce1953e7dd59" title="Create a struct argv based on a format string.">argv_printf_arglist()</a> for more details. The parsed result will be put into argres. </dd></dl>

<p class="definition">Definition at line <a class="el" href="argv_8c_source.html#l00442">442</a> of file <a class="el" href="argv_8c_source.html">argv.c</a>.</p>

<p class="reference">References <a class="el" href="argv_8c_source.html#l00351">argv_printf_arglist()</a>, and <a class="el" href="argv_8c_source.html#l00116">argv_reset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="route_8c_source.html#l01566">add_route()</a>, <a class="el" href="route_8c_source.html#l01877">add_route_ipv6()</a>, <a class="el" href="test__argv_8c_source.html#l00228">argv_insert_head__non_empty_argv__head_added()</a>, <a class="el" href="test__argv_8c_source.html#l00081">argv_printf__combined_path_with_spaces__argc_correct()</a>, <a class="el" href="test__argv_8c_source.html#l00058">argv_printf__embedded_format_directive__replaced_in_output()</a>, <a class="el" href="test__argv_8c_source.html#l00098">argv_printf__empty_parameter__argc_correct()</a>, <a class="el" href="test__argv_8c_source.html#l00070">argv_printf__group_sep_in_arg__fail_no_ouput()</a>, <a class="el" href="test__argv_8c_source.html#l00121">argv_printf__long_args__data_correct()</a>, <a class="el" href="test__argv_8c_source.html#l00035">argv_printf__multiple_spaces_in_format__parsed_as_one()</a>, <a class="el" href="test__argv_8c_source.html#l00046">argv_printf_cat__multiple_spaces_in_format__parsed_as_one()</a>, <a class="el" href="test__argv_8c_source.html#l00166">argv_printf_cat__used_twice__argc_correct()</a>, <a class="el" href="test__argv_8c_source.html#l00193">argv_str__multiple_argv__correct_output()</a>, <a class="el" href="route_8c_source.html#l02159">delete_route()</a>, <a class="el" href="route_8c_source.html#l02353">delete_route_ipv6()</a>, <a class="el" href="tun_8c_source.html#l01209">do_ifconfig_ipv4()</a>, <a class="el" href="tun_8c_source.html#l01011">do_ifconfig_ipv6()</a>, <a class="el" href="socket_8c_source.html#l02453">ipchange_fmt()</a>, <a class="el" href="tun_8c_source.html#l05230">ipconfig_register_dns()</a>, <a class="el" href="multi_8c_source.html#l00096">learn_address_script()</a>, <a class="el" href="multi_8c_source.html#l02067">multi_client_connect_call_plugin_v1()</a>, <a class="el" href="tun_8c_source.html#l06745">netsh_delete_address_dns()</a>, <a class="el" href="tun_8c_source.html#l05556">netsh_enable_dhcp()</a>, <a class="el" href="tun_8c_source.html#l05484">netsh_ifconfig()</a>, <a class="el" href="tun_8c_source.html#l05385">netsh_ifconfig_options()</a>, <a class="el" href="tun_8c_source.html#l05347">netsh_set_dns6_servers()</a>, <a class="el" href="init_8c_source.html#l00105">run_up_down()</a>, <a class="el" href="lladdr_8c_source.html#l00019">set_lladdr()</a>, and <a class="el" href="ssl__verify_8c_source.html#l00481">verify_cert_call_plugin()</a>.</p>

</div>
</div>
<a id="a9d46f76ffdc1b77e783cce1953e7dd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d46f76ffdc1b77e783cce1953e7dd59">&#9670;&nbsp;</a></span>argv_printf_arglist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool argv_printf_arglist </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structargv.html">argv</a> *&#160;</td>
          <td class="paramname"><em>argres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>arglist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a struct argv based on a format string. </p>
<p>Instead of parsing the format string ourselves place delimiters via <a class="el" href="argv_8c.html#ad7fc3237fa205a5371c7d2df0583f908" title="Prepares argv format string for further processing.">argv_prep_format()</a> before we let libc's printf() do the parsing. Then split the resulting string at the injected delimiters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*argres</td><td>Valid pointer to a struct argv where the resulting parsed arguments, based on the format string. </td></tr>
    <tr><td class="paramname">&lt;em&gt;format</td><td>Char string with a printf() compliant format string </td></tr>
    <tr><td class="paramname">arglist</td><td>A va_list with the arguments to be consumed by the format string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the parsing and processing was successfully. If the resulting number of arguments does not match the expected number of arguments (based on the format string), it is considered a failure, which returns false. This can happen if the ASCII Group Separator (GS - 0x1D) is put into the arguments list or format string. </dd></dl>

<p class="definition">Definition at line <a class="el" href="argv_8c_source.html#l00351">351</a> of file <a class="el" href="argv_8c_source.html">argv.c</a>.</p>

<p class="reference">References <a class="el" href="argv_8h_source.html#l00038">argv::argc</a>, <a class="el" href="argv_8c_source.html#l00160">argv_append()</a>, <a class="el" href="argv_8c_source.html#l00290">argv_prep_format()</a>, <a class="el" href="argv_8c_source.html#l00116">argv_reset()</a>, <a class="el" href="http-client_8py_source.html#l00006">http-client::f</a>, <a class="el" href="argv_8h_source.html#l00036">argv::gc</a>, and <a class="el" href="buffer_8c_source.html#l00385">gc_malloc()</a>.</p>

<p class="reference">Referenced by <a class="el" href="argv_8c_source.html#l00442">argv_printf()</a>, and <a class="el" href="argv_8c_source.html#l00466">argv_printf_cat()</a>.</p>

</div>
</div>
<a id="ad62a50a5c6133eaea0422cee6ba840cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62a50a5c6133eaea0422cee6ba840cf">&#9670;&nbsp;</a></span>argv_printf_cat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool argv_printf_cat </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structargv.html">argv</a> *&#160;</td>
          <td class="paramname"><em>argres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>printf() inspired argv concatenation. </p>
<p>Adds arguments to an existing struct argv and populets the argument slots based on the printf() based format string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*argres</td><td>Valid pointer to a struct argv where the result will be put. </td></tr>
    <tr><td class="paramname">*format</td><td>printf() compliant (char *) format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the parsing was successful. See <a class="el" href="argv_8c.html#a9d46f76ffdc1b77e783cce1953e7dd59" title="Create a struct argv based on a format string.">argv_printf_arglist()</a> for more details. The parsed result will be put into argres. </dd></dl>

<p class="definition">Definition at line <a class="el" href="argv_8c_source.html#l00466">466</a> of file <a class="el" href="argv_8c_source.html">argv.c</a>.</p>

<p class="reference">References <a class="el" href="argv_8c_source.html#l00351">argv_printf_arglist()</a>.</p>

<p class="reference">Referenced by <a class="el" href="route_8c_source.html#l01566">add_route()</a>, <a class="el" href="route_8c_source.html#l01877">add_route_ipv6()</a>, <a class="el" href="test__argv_8c_source.html#l00154">argv_parse_cmd__command_and_extra_options__argc_correct()</a>, <a class="el" href="test__argv_8c_source.html#l00046">argv_printf_cat__multiple_spaces_in_format__parsed_as_one()</a>, <a class="el" href="test__argv_8c_source.html#l00166">argv_printf_cat__used_twice__argc_correct()</a>, <a class="el" href="test__argv_8c_source.html#l00193">argv_str__multiple_argv__correct_output()</a>, <a class="el" href="route_8c_source.html#l02353">delete_route_ipv6()</a>, <a class="el" href="socket_8c_source.html#l02453">ipchange_fmt()</a>, <a class="el" href="multi_8c_source.html#l00096">learn_address_script()</a>, <a class="el" href="multi_8c_source.html#l02259">multi_client_connect_call_script()</a>, <a class="el" href="tun_8c_source.html#l05385">netsh_ifconfig_options()</a>, <a class="el" href="tun_8c_source.html#l05347">netsh_set_dns6_servers()</a>, <a class="el" href="init_8c_source.html#l00105">run_up_down()</a>, <a class="el" href="ssl__verify_8c_source.html#l00549">verify_cert_call_command()</a>, and <a class="el" href="ssl__verify_8c_source.html#l01104">verify_user_pass_script()</a>.</p>

</div>
</div>
<a id="a5eeef6841700aa0a4e4e426d1d13dc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eeef6841700aa0a4e4e426d1d13dc45">&#9670;&nbsp;</a></span>argv_reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void argv_reset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structargv.html">argv</a> *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the struct argv to an initial state. </p>
<p>No memory buffers will be released by this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*a</td><td>Valid pointer to a struct argv to resize </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="argv_8c_source.html#l00116">116</a> of file <a class="el" href="argv_8c_source.html">argv.c</a>.</p>

<p class="reference">References <a class="el" href="argv_8h_source.html#l00038">argv::argc</a>, and <a class="el" href="argv_8h_source.html#l00039">argv::argv</a>.</p>

<p class="reference">Referenced by <a class="el" href="argv_8c_source.html#l00485">argv_parse_cmd()</a>, <a class="el" href="argv_8c_source.html#l00442">argv_printf()</a>, and <a class="el" href="argv_8c_source.html#l00351">argv_printf_arglist()</a>.</p>

</div>
</div>
<a id="a969eb3c616318512e53d20ec4990dcc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a969eb3c616318512e53d20ec4990dcc2">&#9670;&nbsp;</a></span>argv_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* argv_str </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structargv.html">argv</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structgc__arena.html">gc_arena</a> *&#160;</td>
          <td class="paramname"><em>gc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a single string with all the arguments in a struct argv concatenated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*a</td><td>Valid pointer to the struct argv with the arguments to list </td></tr>
    <tr><td class="paramname">*gc</td><td>Pointer to a struct <a class="el" href="structgc__arena.html" title="Garbage collection arena used to keep track of dynamically allocated memory.">gc_arena</a> managed buffer </td></tr>
    <tr><td class="paramname">flags</td><td>Flags passed to the <a class="el" href="buffer_8c.html#a9fa59da93f5503603025786ec8f33726">print_argv()</a> function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a string generated by <a class="el" href="buffer_8c.html#a9fa59da93f5503603025786ec8f33726">print_argv()</a> with all the arguments concatenated. If the argument count is 0, it will return an empty string. The return string is allocated in the <a class="el" href="structgc__arena.html" title="Garbage collection arena used to keep track of dynamically allocated memory.">gc_arena</a> managed buffer. If the <a class="el" href="structgc__arena.html" title="Garbage collection arena used to keep track of dynamically allocated memory.">gc_arena</a> pointer is NULL, the returned string must be free()d explicitly to avoid memory leaks. </dd></dl>

<p class="definition">Definition at line <a class="el" href="argv_8c_source.html#l00233">233</a> of file <a class="el" href="argv_8c_source.html">argv.c</a>.</p>

<p class="reference">References <a class="el" href="argv_8h_source.html#l00039">argv::argv</a>, <a class="el" href="argv_8h_source.html#l00036">argv::gc</a>, and <a class="el" href="buffer_8c_source.html#l00733">print_argv()</a>.</p>

<p class="reference">Referenced by <a class="el" href="argv_8c_source.html#l00245">argv_msg()</a>, <a class="el" href="argv_8c_source.html#l00262">argv_msg_prefix()</a>, <a class="el" href="test__argv_8c_source.html#l00179">argv_str__empty_argv__empty_output()</a>, and <a class="el" href="test__argv_8c_source.html#l00193">argv_str__multiple_argv__correct_output()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
