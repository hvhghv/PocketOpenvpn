<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVPN: Reliable</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVPN
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">Reliable</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreliable__ack.html">reliable_ack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The acknowledgment structure in which packet IDs are stored for later acknowledgment.  <a href="structreliable__ack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreliable__entry.html">reliable_entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure in which the reliability layer stores a single incoming or outgoing packet.  <a href="structreliable__entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreliable.html">reliable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reliability layer storage structure for one VPN tunnel's control channel in one direction.  <a href="structreliable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gacb891f0bfc023839a53a2c7005cd340c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#gacb891f0bfc023839a53a2c7005cd340c">EXPONENTIAL_BACKOFF</a></td></tr>
<tr class="separator:gacb891f0bfc023839a53a2c7005cd340c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91ccbc389e490d03321b1a6de0dd096d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga91ccbc389e490d03321b1a6de0dd096d">RELIABLE_ACK_SIZE</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:ga91ccbc389e490d03321b1a6de0dd096d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of packet IDs waiting to be acknowledged which can be stored in one <code><a class="el" href="structreliable__ack.html" title="The acknowledgment structure in which packet IDs are stored for later acknowledgment.">reliable_ack</a></code> structure.  <a href="group__reliable.html#ga91ccbc389e490d03321b1a6de0dd096d">More...</a><br /></td></tr>
<tr class="separator:ga91ccbc389e490d03321b1a6de0dd096d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa626a13dc31bf131a92548b9b2810cba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#gaa626a13dc31bf131a92548b9b2810cba">RELIABLE_CAPACITY</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:gaa626a13dc31bf131a92548b9b2810cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of packets that the reliability layer for one VPN tunnel in one direction can store.  <a href="group__reliable.html#gaa626a13dc31bf131a92548b9b2810cba">More...</a><br /></td></tr>
<tr class="separator:gaa626a13dc31bf131a92548b9b2810cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for processing incoming acknowledgments</h2></td></tr>
<tr class="memitem:ga03d3c93ec4c15d57947740a56eae0aec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga03d3c93ec4c15d57947740a56eae0aec">reliable_ack_read</a> (struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *ack, struct <a class="el" href="structbuffer.html">buffer</a> *buf, const struct <a class="el" href="structsession__id.html">session_id</a> *sid)</td></tr>
<tr class="memdesc:ga03d3c93ec4c15d57947740a56eae0aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an acknowledgment record from a received packet.  <a href="group__reliable.html#ga03d3c93ec4c15d57947740a56eae0aec">More...</a><br /></td></tr>
<tr class="separator:ga03d3c93ec4c15d57947740a56eae0aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a9f750ec286ebf613f115757ce197d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga6a9f750ec286ebf613f115757ce197d0">reliable_send_purge</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel, const struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *ack)</td></tr>
<tr class="memdesc:ga6a9f750ec286ebf613f115757ce197d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove acknowledged packets from a reliable structure.  <a href="group__reliable.html#ga6a9f750ec286ebf613f115757ce197d0">More...</a><br /></td></tr>
<tr class="separator:ga6a9f750ec286ebf613f115757ce197d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for processing outgoing acknowledgments</h2></td></tr>
<tr class="memitem:gaffcaeca9c9dd45e407e7ca32bbcd2eba"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#gaffcaeca9c9dd45e407e7ca32bbcd2eba">reliable_ack_empty</a> (struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *ack)</td></tr>
<tr class="memdesc:gaffcaeca9c9dd45e407e7ca32bbcd2eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether an acknowledgment structure contains any packet IDs to be acknowledged.  <a href="group__reliable.html#gaffcaeca9c9dd45e407e7ca32bbcd2eba">More...</a><br /></td></tr>
<tr class="separator:gaffcaeca9c9dd45e407e7ca32bbcd2eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6875d0fb65bdd960736068b2e0fe4a29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga6875d0fb65bdd960736068b2e0fe4a29">reliable_ack_write</a> (struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *ack, struct <a class="el" href="structbuffer.html">buffer</a> *buf, const struct <a class="el" href="structsession__id.html">session_id</a> *sid, int max, bool prepend)</td></tr>
<tr class="memdesc:ga6875d0fb65bdd960736068b2e0fe4a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a packet ID acknowledgment record to a buffer.  <a href="group__reliable.html#ga6875d0fb65bdd960736068b2e0fe4a29">More...</a><br /></td></tr>
<tr class="separator:ga6875d0fb65bdd960736068b2e0fe4a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for initialization and cleanup</h2></td></tr>
<tr class="memitem:gab5e5ef6d6fd862187abe76f88b972ee5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#gab5e5ef6d6fd862187abe76f88b972ee5">reliable_init</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel, int buf_size, int offset, int array_size, bool hold)</td></tr>
<tr class="memdesc:gab5e5ef6d6fd862187abe76f88b972ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a reliable structure.  <a href="group__reliable.html#gab5e5ef6d6fd862187abe76f88b972ee5">More...</a><br /></td></tr>
<tr class="separator:gab5e5ef6d6fd862187abe76f88b972ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0315c8ecda1aafbfb61e6ab1b8c2477b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga0315c8ecda1aafbfb61e6ab1b8c2477b">reliable_free</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel)</td></tr>
<tr class="memdesc:ga0315c8ecda1aafbfb61e6ab1b8c2477b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free allocated memory associated with a reliable structure.  <a href="group__reliable.html#ga0315c8ecda1aafbfb61e6ab1b8c2477b">More...</a><br /></td></tr>
<tr class="separator:ga0315c8ecda1aafbfb61e6ab1b8c2477b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf4135caf45a800b9accff968aaa59d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#gaaf4135caf45a800b9accff968aaa59d6">reliable_ack_adjust_frame_parameters</a> (struct <a class="el" href="structframe.html">frame</a> *<a class="el" href="structframe.html">frame</a>, int max)</td></tr>
<tr class="separator:gaaf4135caf45a800b9accff968aaa59d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for inserting incoming packets</h2></td></tr>
<tr class="memitem:ga68f5e71b155cdcfabca18d028d336311"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga68f5e71b155cdcfabca18d028d336311">reliable_can_get</a> (const struct <a class="el" href="structreliable.html">reliable</a> *rel)</td></tr>
<tr class="memdesc:ga68f5e71b155cdcfabca18d028d336311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a reliable structure has any free buffers available for use.  <a href="group__reliable.html#ga68f5e71b155cdcfabca18d028d336311">More...</a><br /></td></tr>
<tr class="separator:ga68f5e71b155cdcfabca18d028d336311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga907fd32837c50b4266eb5db1c56f9b13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga907fd32837c50b4266eb5db1c56f9b13">reliable_not_replay</a> (const struct <a class="el" href="structreliable.html">reliable</a> *rel, <a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a> id)</td></tr>
<tr class="memdesc:ga907fd32837c50b4266eb5db1c56f9b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that a received packet's ID is not a replay.  <a href="group__reliable.html#ga907fd32837c50b4266eb5db1c56f9b13">More...</a><br /></td></tr>
<tr class="separator:ga907fd32837c50b4266eb5db1c56f9b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d6e3bde9beced3d69bbba652730439"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#gad2d6e3bde9beced3d69bbba652730439">reliable_wont_break_sequentiality</a> (const struct <a class="el" href="structreliable.html">reliable</a> *rel, <a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a> id)</td></tr>
<tr class="memdesc:gad2d6e3bde9beced3d69bbba652730439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that a received packet's ID can safely be stored in the reliable structure's processing window.  <a href="group__reliable.html#gad2d6e3bde9beced3d69bbba652730439">More...</a><br /></td></tr>
<tr class="separator:gad2d6e3bde9beced3d69bbba652730439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21a2f2e1296cea87eb6d68331667fc9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga21a2f2e1296cea87eb6d68331667fc9e">reliable_ack_read_packet_id</a> (struct <a class="el" href="structbuffer.html">buffer</a> *buf, <a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a> *pid)</td></tr>
<tr class="memdesc:ga21a2f2e1296cea87eb6d68331667fc9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the packet ID of a received packet.  <a href="group__reliable.html#ga21a2f2e1296cea87eb6d68331667fc9e">More...</a><br /></td></tr>
<tr class="separator:ga21a2f2e1296cea87eb6d68331667fc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69117718f8e1e22881d957e219134ff"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#gaa69117718f8e1e22881d957e219134ff">reliable_get_buf</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel)</td></tr>
<tr class="memdesc:gaa69117718f8e1e22881d957e219134ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer of a free reliable entry in which to store a packet.  <a href="group__reliable.html#gaa69117718f8e1e22881d957e219134ff">More...</a><br /></td></tr>
<tr class="separator:gaa69117718f8e1e22881d957e219134ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2689b44850ce41cc2fe1fc7f57657eb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga2689b44850ce41cc2fe1fc7f57657eb4">reliable_mark_active_incoming</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel, struct <a class="el" href="structbuffer.html">buffer</a> *buf, <a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a> pid, int opcode)</td></tr>
<tr class="memdesc:ga2689b44850ce41cc2fe1fc7f57657eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the reliable entry associated with the given buffer as active incoming.  <a href="group__reliable.html#ga2689b44850ce41cc2fe1fc7f57657eb4">More...</a><br /></td></tr>
<tr class="separator:ga2689b44850ce41cc2fe1fc7f57657eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bdc89dd24741d52a2fcf8182389b947"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga3bdc89dd24741d52a2fcf8182389b947">reliable_ack_acknowledge_packet_id</a> (struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *ack, <a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a> pid)</td></tr>
<tr class="memdesc:ga3bdc89dd24741d52a2fcf8182389b947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record a packet ID for later acknowledgment.  <a href="group__reliable.html#ga3bdc89dd24741d52a2fcf8182389b947">More...</a><br /></td></tr>
<tr class="separator:ga3bdc89dd24741d52a2fcf8182389b947"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for extracting incoming packets</h2></td></tr>
<tr class="memitem:ga08f53328657f0172eb061193171e2a41"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga08f53328657f0172eb061193171e2a41">reliable_get_buf_sequenced</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel)</td></tr>
<tr class="memdesc:ga08f53328657f0172eb061193171e2a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer of the next sequential and active entry.  <a href="group__reliable.html#ga08f53328657f0172eb061193171e2a41">More...</a><br /></td></tr>
<tr class="separator:ga08f53328657f0172eb061193171e2a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c51920665fa9c34f082dd7aa6ce0e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga5c51920665fa9c34f082dd7aa6ce0e55">reliable_mark_deleted</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel, struct <a class="el" href="structbuffer.html">buffer</a> *buf, bool inc_pid)</td></tr>
<tr class="memdesc:ga5c51920665fa9c34f082dd7aa6ce0e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an entry from a reliable structure.  <a href="group__reliable.html#ga5c51920665fa9c34f082dd7aa6ce0e55">More...</a><br /></td></tr>
<tr class="separator:ga5c51920665fa9c34f082dd7aa6ce0e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for inserting outgoing packets</h2></td></tr>
<tr class="memitem:gaa15b0672f4ddd65d55194ed5bde0e1c8"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#gaa15b0672f4ddd65d55194ed5bde0e1c8">reliable_get_buf_output_sequenced</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel)</td></tr>
<tr class="memdesc:gaa15b0672f4ddd65d55194ed5bde0e1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer of free reliable entry and check whether the outgoing acknowledgment sequence is still okay.  <a href="group__reliable.html#gaa15b0672f4ddd65d55194ed5bde0e1c8">More...</a><br /></td></tr>
<tr class="separator:gaa15b0672f4ddd65d55194ed5bde0e1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c03b5ae47fe72dbf4fe16f11ea1c091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga2c03b5ae47fe72dbf4fe16f11ea1c091">reliable_mark_active_outgoing</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel, struct <a class="el" href="structbuffer.html">buffer</a> *buf, int opcode)</td></tr>
<tr class="memdesc:ga2c03b5ae47fe72dbf4fe16f11ea1c091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the reliable entry associated with the given buffer as active outgoing.  <a href="group__reliable.html#ga2c03b5ae47fe72dbf4fe16f11ea1c091">More...</a><br /></td></tr>
<tr class="separator:ga2c03b5ae47fe72dbf4fe16f11ea1c091"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for extracting outgoing packets</h2></td></tr>
<tr class="memitem:ga79e86f7694ffbd592d944f8f45efa7c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga79e86f7694ffbd592d944f8f45efa7c8">reliable_can_send</a> (const struct <a class="el" href="structreliable.html">reliable</a> *rel)</td></tr>
<tr class="memdesc:ga79e86f7694ffbd592d944f8f45efa7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a reliable structure has any active entries ready to be (re)sent.  <a href="group__reliable.html#ga79e86f7694ffbd592d944f8f45efa7c8">More...</a><br /></td></tr>
<tr class="separator:ga79e86f7694ffbd592d944f8f45efa7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebcf7ae7a144f32b55c9af5c51121ec1"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#gaebcf7ae7a144f32b55c9af5c51121ec1">reliable_send</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel, int *opcode)</td></tr>
<tr class="memdesc:gaebcf7ae7a144f32b55c9af5c51121ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next packet to send to the remote peer.  <a href="group__reliable.html#gaebcf7ae7a144f32b55c9af5c51121ec1">More...</a><br /></td></tr>
<tr class="separator:gaebcf7ae7a144f32b55c9af5c51121ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Miscellaneous functions</h2></td></tr>
<tr class="memitem:ga7e0186d08bdeb59563ce37578ee64f8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga7e0186d08bdeb59563ce37578ee64f8d">reliable_empty</a> (const struct <a class="el" href="structreliable.html">reliable</a> *rel)</td></tr>
<tr class="memdesc:ga7e0186d08bdeb59563ce37578ee64f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a reliable structure is empty.  <a href="group__reliable.html#ga7e0186d08bdeb59563ce37578ee64f8d">More...</a><br /></td></tr>
<tr class="separator:ga7e0186d08bdeb59563ce37578ee64f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e8edfca42338da6da6ccb3fd1849dca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="common_8h.html#a3d8621f960ada51a5ad9ff181730481a">interval_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga9e8edfca42338da6da6ccb3fd1849dca">reliable_send_timeout</a> (const struct <a class="el" href="structreliable.html">reliable</a> *rel)</td></tr>
<tr class="memdesc:ga9e8edfca42338da6da6ccb3fd1849dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determined how many seconds until the earliest resend should be attempted.  <a href="group__reliable.html#ga9e8edfca42338da6da6ccb3fd1849dca">More...</a><br /></td></tr>
<tr class="separator:ga9e8edfca42338da6da6ccb3fd1849dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14cb4395f780502ae9edbe6d3f90aec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga14cb4395f780502ae9edbe6d3f90aec5">reliable_schedule_now</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel)</td></tr>
<tr class="memdesc:ga14cb4395f780502ae9edbe6d3f90aec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reschedule all entries of a reliable structure to be ready for (re)sending immediately.  <a href="group__reliable.html#ga14cb4395f780502ae9edbe6d3f90aec5">More...</a><br /></td></tr>
<tr class="separator:ga14cb4395f780502ae9edbe6d3f90aec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga864d5a93bec5ac5554ce9481d1551197"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga864d5a93bec5ac5554ce9481d1551197">reliable_debug_print</a> (const struct <a class="el" href="structreliable.html">reliable</a> *rel, char *desc)</td></tr>
<tr class="separator:ga864d5a93bec5ac5554ce9481d1551197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5950f411ad409250922e2f792aecb61f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga5950f411ad409250922e2f792aecb61f">reliable_set_timeout</a> (struct <a class="el" href="structreliable.html">reliable</a> *rel, <a class="el" href="common_8h.html#a3d8621f960ada51a5ad9ff181730481a">interval_t</a> timeout)</td></tr>
<tr class="separator:ga5950f411ad409250922e2f792aecb61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b9917d2ee4fe23f48f4471e8f4f4fdd"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga6b9917d2ee4fe23f48f4471e8f4f4fdd">reliable_ack_print</a> (struct <a class="el" href="structbuffer.html">buffer</a> *buf, bool verbose, struct <a class="el" href="structgc__arena.html">gc_arena</a> *gc)</td></tr>
<tr class="separator:ga6b9917d2ee4fe23f48f4471e8f4f4fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e35eb4bd321de7b34aa1f086451f724"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reliable.html#ga1e35eb4bd321de7b34aa1f086451f724">reliable_ack_debug_print</a> (const struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *ack, char *desc)</td></tr>
<tr class="separator:ga1e35eb4bd321de7b34aa1f086451f724"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gacb891f0bfc023839a53a2c7005cd340c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb891f0bfc023839a53a2c7005cd340c">&#9670;&nbsp;</a></span>EXPONENTIAL_BACKOFF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXPONENTIAL_BACKOFF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="reliable_8h_source.html#l00044">44</a> of file <a class="el" href="reliable_8h_source.html">reliable.h</a>.</p>

</div>
</div>
<a id="ga91ccbc389e490d03321b1a6de0dd096d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91ccbc389e490d03321b1a6de0dd096d">&#9670;&nbsp;</a></span>RELIABLE_ACK_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RELIABLE_ACK_SIZE&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of packet IDs waiting to be acknowledged which can be stored in one <code><a class="el" href="structreliable__ack.html" title="The acknowledgment structure in which packet IDs are stored for later acknowledgment.">reliable_ack</a></code> structure. </p>

<p class="definition">Definition at line <a class="el" href="reliable_8h_source.html#l00046">46</a> of file <a class="el" href="reliable_8h_source.html">reliable.h</a>.</p>

</div>
</div>
<a id="gaa626a13dc31bf131a92548b9b2810cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa626a13dc31bf131a92548b9b2810cba">&#9670;&nbsp;</a></span>RELIABLE_CAPACITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RELIABLE_CAPACITY&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum number of packets that the reliability layer for one VPN tunnel in one direction can store. </p>

<p class="definition">Definition at line <a class="el" href="reliable_8h_source.html#l00051">51</a> of file <a class="el" href="reliable_8h_source.html">reliable.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3bdc89dd24741d52a2fcf8182389b947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bdc89dd24741d52a2fcf8182389b947">&#9670;&nbsp;</a></span>reliable_ack_acknowledge_packet_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool reliable_ack_acknowledge_packet_id </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *&#160;</td>
          <td class="paramname"><em>ack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a>&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record a packet ID for later acknowledgment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ack</td><td>The acknowledgment structure which stores this VPN tunnel's packet IDs for later acknowledgment. </td></tr>
    <tr><td class="paramname">pid</td><td>The packet ID of the received packet which should be acknowledged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if the packet ID was added to <em>ack</em>. </li>
<li>False, if the packet ID was already present in <em>ack</em> or <em>ack</em> has no free space to store any more packet IDs. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00141">141</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="errlevel_8h_source.html#l00159">D_REL_DEBUG</a>, <a class="el" href="errlevel_8h_source.html#l00121">D_REL_LOW</a>, <a class="el" href="openvpn_2error_8h_source.html#l00171">dmsg</a>, <a class="el" href="reliable_8h_source.html#l00061">reliable_ack::len</a>, <a class="el" href="reliable_8h_source.html#l00062">reliable_ack::packet_id</a>, <a class="el" href="packet__id_8h_source.html#l00095">packet_id_format</a>, <a class="el" href="reliable_8c_source.html#l00108">reliable_ack_packet_id_present()</a>, and <a class="el" href="reliable_8h_source.html#l00046">RELIABLE_ACK_SIZE</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l03303">tls_pre_decrypt()</a>.</p>

</div>
</div>
<a id="gaaf4135caf45a800b9accff968aaa59d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf4135caf45a800b9accff968aaa59d6">&#9670;&nbsp;</a></span>reliable_ack_adjust_frame_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_ack_adjust_frame_parameters </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structframe.html">frame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00258">258</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="reliable_8c_source.html#l00208">ACK_SIZE</a>, and <a class="el" href="mtu_8h_source.html#l00274">frame_add_to_extra_frame()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l00315">tls_init_control_channel_frame_parameters()</a>.</p>

</div>
</div>
<a id="ga1e35eb4bd321de7b34aa1f086451f724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e35eb4bd321de7b34aa1f086451f724">&#9670;&nbsp;</a></span>reliable_ack_debug_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_ack_debug_print </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *&#160;</td>
          <td class="paramname"><em>ack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaffcaeca9c9dd45e407e7ca32bbcd2eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffcaeca9c9dd45e407e7ca32bbcd2eba">&#9670;&nbsp;</a></span>reliable_ack_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool reliable_ack_empty </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *&#160;</td>
          <td class="paramname"><em>ack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether an acknowledgment structure contains any packet IDs to be acknowledged. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ack</td><td>The acknowledgment structure to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if the acknowledgment structure is empty. </li>
<li>False, if there are packet IDs to be acknowledged. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="reliable_8h_source.html#l00146">146</a> of file <a class="el" href="reliable_8h_source.html">reliable.h</a>.</p>

<p class="reference">References <a class="el" href="reliable_8h_source.html#l00061">reliable_ack::len</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l02649">tls_process()</a>.</p>

</div>
</div>
<a id="ga6b9917d2ee4fe23f48f4471e8f4f4fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b9917d2ee4fe23f48f4471e8f4f4fdd">&#9670;&nbsp;</a></span>reliable_ack_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* reliable_ack_print </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structgc__arena.html">gc_arena</a> *&#160;</td>
          <td class="paramname"><em>gc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00265">265</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="buffer_8c_source.html#l00090">alloc_buf_gc()</a>, <a class="el" href="buffer_8h_source.html#l00129">BSTR</a>, <a class="el" href="buffer_8c_source.html#l00245">buf_printf()</a>, <a class="el" href="buffer_8h_source.html#l00784">buf_read()</a>, <a class="el" href="packet__id_8h_source.html#l00064">ntohpid</a>, <a class="el" href="packet__id_8h_source.html#l00095">packet_id_format</a>, <a class="el" href="session__id_8c_source.html#l00057">session_id_print()</a>, and <a class="el" href="session__id_8h_source.html#l00061">session_id_read()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l04024">protocol_dump()</a>.</p>

</div>
</div>
<a id="ga03d3c93ec4c15d57947740a56eae0aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03d3c93ec4c15d57947740a56eae0aec">&#9670;&nbsp;</a></span>reliable_ack_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool reliable_ack_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *&#160;</td>
          <td class="paramname"><em>ack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsession__id.html">session_id</a> *&#160;</td>
          <td class="paramname"><em>sid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an acknowledgment record from a received packet. </p>
<p>This function reads the packet ID acknowledgment record from the packet contained in <em>buf</em>. If the record contains acknowledgments, these are stored in <em>ack</em>. This function also compares the packet's session ID with the expected session ID <em>sid</em>, which should be equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ack</td><td>The acknowledgment structure in which received acknowledgments are to be stored. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer containing the packet. </td></tr>
    <tr><td class="paramname">sid</td><td>The expected session ID to compare to the session ID in the packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if processing was successful. </li>
<li>False, if an error occurs during processing. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00158">158</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00784">buf_read()</a>, <a class="el" href="errlevel_8h_source.html#l00121">D_REL_LOW</a>, <a class="el" href="openvpn_2error_8h_source.html#l00171">dmsg</a>, <a class="el" href="buffer_8h_source.html#l01032">gc_free()</a>, <a class="el" href="buffer_8h_source.html#l01024">gc_new()</a>, <a class="el" href="reliable_8h_source.html#l00061">reliable_ack::len</a>, <a class="el" href="packet__id_8h_source.html#l00064">ntohpid</a>, <a class="el" href="reliable_8h_source.html#l00062">reliable_ack::packet_id</a>, <a class="el" href="reliable_8h_source.html#l00046">RELIABLE_ACK_SIZE</a>, <a class="el" href="session__id_8h_source.html#l00055">session_id_defined()</a>, <a class="el" href="session__id_8h_source.html#l00048">session_id_equal()</a>, <a class="el" href="session__id_8c_source.html#l00057">session_id_print()</a>, and <a class="el" href="session__id_8h_source.html#l00061">session_id_read()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l03303">tls_pre_decrypt()</a>.</p>

</div>
</div>
<a id="ga21a2f2e1296cea87eb6d68331667fc9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21a2f2e1296cea87eb6d68331667fc9e">&#9670;&nbsp;</a></span>reliable_ack_read_packet_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool reliable_ack_read_packet_id </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a> *&#160;</td>
          <td class="paramname"><em>pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the packet ID of a received packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer containing the received packet. </td></tr>
    <tr><td class="paramname">pid</td><td>A pointer where the packet's packet ID will be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if processing was successful. </li>
<li>False, if an error occurs during processing. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00123">123</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l00784">buf_read()</a>, <a class="el" href="errlevel_8h_source.html#l00159">D_REL_DEBUG</a>, <a class="el" href="errlevel_8h_source.html#l00121">D_REL_LOW</a>, <a class="el" href="openvpn_2error_8h_source.html#l00171">dmsg</a>, <a class="el" href="buffer_8h_source.html#l00066">buffer::len</a>, <a class="el" href="packet__id_8h_source.html#l00064">ntohpid</a>, and <a class="el" href="packet__id_8h_source.html#l00095">packet_id_format</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l03303">tls_pre_decrypt()</a>.</p>

</div>
</div>
<a id="ga6875d0fb65bdd960736068b2e0fe4a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6875d0fb65bdd960736068b2e0fe4a29">&#9670;&nbsp;</a></span>reliable_ack_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool reliable_ack_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *&#160;</td>
          <td class="paramname"><em>ack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsession__id.html">session_id</a> *&#160;</td>
          <td class="paramname"><em>sid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prepend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a packet ID acknowledgment record to a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ack</td><td>The acknowledgment structure containing packet IDs to be acknowledged. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer into which the acknowledgment record will be written. </td></tr>
    <tr><td class="paramname">sid</td><td>The session ID of the VPN tunnel associated with the packet IDs to be acknowledged. </td></tr>
    <tr><td class="paramname">max</td><td>The maximum number of acknowledgments to be written in the record. </td></tr>
    <tr><td class="paramname">prepend</td><td>If true, prepend the acknowledgment record in the buffer; if false, write into the buffer's current position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if processing was successful. </li>
<li>False, if an error occurs during processing. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00213">213</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="reliable_8c_source.html#l00208">ACK_SIZE</a>, <a class="el" href="openvpn_2error_8h_source.html#l00218">ASSERT</a>, <a class="el" href="buffer_8h_source.html#l00128">BDEF</a>, <a class="el" href="buffer_8c_source.html#l00226">buf_sub()</a>, <a class="el" href="buffer_8h_source.html#l00673">buf_write()</a>, <a class="el" href="errlevel_8h_source.html#l00159">D_REL_DEBUG</a>, <a class="el" href="openvpn_2error_8h_source.html#l00171">dmsg</a>, <a class="el" href="packet__id_8h_source.html#l00061">htonpid</a>, <a class="el" href="reliable_8h_source.html#l00061">reliable_ack::len</a>, <a class="el" href="reliable_8h_source.html#l00062">reliable_ack::packet_id</a>, <a class="el" href="packet__id_8h_source.html#l00095">packet_id_format</a>, <a class="el" href="session__id_8h_source.html#l00055">session_id_defined()</a>, and <a class="el" href="session__id_8h_source.html#l00073">session_id_write()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l01452">write_control_auth()</a>.</p>

</div>
</div>
<a id="ga68f5e71b155cdcfabca18d028d336311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68f5e71b155cdcfabca18d028d336311">&#9670;&nbsp;</a></span>reliable_can_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool reliable_can_get </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a reliable structure has any free buffers available for use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if at least one buffer is available for use. </li>
<li>False, if all the buffers are active. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00407">407</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="reliable_8h_source.html#l00071">reliable_entry::active</a>, <a class="el" href="reliable_8h_source.html#l00090">array</a>, <a class="el" href="errlevel_8h_source.html#l00121">D_REL_LOW</a>, <a class="el" href="openvpn_2error_8h_source.html#l00171">dmsg</a>, <a class="el" href="buffer_8h_source.html#l01032">gc_free()</a>, <a class="el" href="buffer_8h_source.html#l01024">gc_new()</a>, <a class="el" href="reliable_8c_source.html#l00388">reliable_print_ids()</a>, and <a class="el" href="reliable_8h_source.html#l00085">size</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l03303">tls_pre_decrypt()</a>.</p>

</div>
</div>
<a id="ga79e86f7694ffbd592d944f8f45efa7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79e86f7694ffbd592d944f8f45efa7c8">&#9670;&nbsp;</a></span>reliable_can_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool reliable_can_send </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a reliable structure has any active entries ready to be (re)sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if there are active entries ready to be (re)sent president. </li>
<li>False, if there are no active entries, or the active entries are not yet ready for resending. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00542">542</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="reliable_8h_source.html#l00071">reliable_entry::active</a>, <a class="el" href="reliable_8h_source.html#l00090">array</a>, <a class="el" href="errlevel_8h_source.html#l00159">D_REL_DEBUG</a>, <a class="el" href="openvpn_2error_8h_source.html#l00171">dmsg</a>, <a class="el" href="buffer_8h_source.html#l01032">gc_free()</a>, <a class="el" href="buffer_8h_source.html#l01024">gc_new()</a>, <a class="el" href="reliable_8h_source.html#l00089">hold</a>, <a class="el" href="reliable_8h_source.html#l00073">reliable_entry::next_try</a>, <a class="el" href="otime_8c_source.html#l00036">now</a>, <a class="el" href="reliable_8c_source.html#l00388">reliable_print_ids()</a>, and <a class="el" href="reliable_8h_source.html#l00085">size</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l02649">tls_process()</a>.</p>

</div>
</div>
<a id="ga864d5a93bec5ac5554ce9481d1551197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga864d5a93bec5ac5554ce9481d1551197">&#9670;&nbsp;</a></span>reliable_debug_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_debug_print </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7e0186d08bdeb59563ce37578ee64f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e0186d08bdeb59563ce37578ee64f8d">&#9670;&nbsp;</a></span>reliable_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool reliable_empty </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a reliable structure is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if there are no active entries in the given reliable structure. </li>
<li>False, if there is at least one active entry present. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00339">339</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="reliable_8h_source.html#l00071">reliable_entry::active</a>, <a class="el" href="reliable_8h_source.html#l00090">array</a>, and <a class="el" href="reliable_8h_source.html#l00085">size</a>.</p>

</div>
</div>
<a id="ga0315c8ecda1aafbfb61e6ab1b8c2477b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0315c8ecda1aafbfb61e6ab1b8c2477b">&#9670;&nbsp;</a></span>reliable_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free allocated memory associated with a reliable structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structured to clean up. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00327">327</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="reliable_8h_source.html#l00090">array</a>, <a class="el" href="reliable_8h_source.html#l00076">reliable_entry::buf</a>, <a class="el" href="buffer_8c_source.html#l00185">free_buf()</a>, and <a class="el" href="reliable_8h_source.html#l00085">size</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l00996">key_state_free()</a>.</p>

</div>
</div>
<a id="gaa69117718f8e1e22881d957e219134ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa69117718f8e1e22881d957e219134ff">&#9670;&nbsp;</a></span>reliable_get_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbuffer.html">buffer</a>* reliable_get_buf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer of a free reliable entry in which to store a packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure in which to search for a free entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a buffer of a free entry in the <em>rel</em> reliable structure. If there are no free entries available, this function returns NULL. </dd></dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00473">473</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="reliable_8h_source.html#l00071">reliable_entry::active</a>, <a class="el" href="reliable_8h_source.html#l00090">array</a>, <a class="el" href="openvpn_2error_8h_source.html#l00218">ASSERT</a>, <a class="el" href="reliable_8h_source.html#l00076">reliable_entry::buf</a>, <a class="el" href="buffer_8h_source.html#l00196">buf_init</a>, <a class="el" href="reliable_8h_source.html#l00088">offset</a>, and <a class="el" href="reliable_8h_source.html#l00085">size</a>.</p>

<p class="reference">Referenced by <a class="el" href="reliable_8c_source.html#l00490">reliable_get_buf_output_sequenced()</a>, and <a class="el" href="ssl_8c_source.html#l03303">tls_pre_decrypt()</a>.</p>

</div>
</div>
<a id="gaa15b0672f4ddd65d55194ed5bde0e1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa15b0672f4ddd65d55194ed5bde0e1c8">&#9670;&nbsp;</a></span>reliable_get_buf_output_sequenced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbuffer.html">buffer</a>* reliable_get_buf_output_sequenced </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer of free reliable entry and check whether the outgoing acknowledgment sequence is still okay. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure in which to search for a free entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a buffer of a free entry in the <em>rel</em> reliable structure. If there are no free entries available, this function returns NULL. If the outgoing acknowledgment sequence is broken, this function also returns NULL. </dd></dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00490">490</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="reliable_8h_source.html#l00071">reliable_entry::active</a>, <a class="el" href="reliable_8h_source.html#l00090">array</a>, <a class="el" href="errlevel_8h_source.html#l00121">D_REL_LOW</a>, <a class="el" href="openvpn_2error_8h_source.html#l00171">dmsg</a>, <a class="el" href="buffer_8h_source.html#l01032">gc_free()</a>, <a class="el" href="buffer_8h_source.html#l01024">gc_new()</a>, <a class="el" href="reliable_8h_source.html#l00074">reliable_entry::packet_id</a>, <a class="el" href="reliable_8h_source.html#l00087">packet_id</a>, <a class="el" href="reliable_8c_source.html#l00473">reliable_get_buf()</a>, <a class="el" href="reliable_8c_source.html#l00048">reliable_pid_in_range1()</a>, <a class="el" href="reliable_8c_source.html#l00100">reliable_pid_min()</a>, <a class="el" href="reliable_8c_source.html#l00388">reliable_print_ids()</a>, and <a class="el" href="reliable_8h_source.html#l00085">size</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l02649">tls_process()</a>.</p>

</div>
</div>
<a id="ga08f53328657f0172eb061193171e2a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08f53328657f0172eb061193171e2a41">&#9670;&nbsp;</a></span>reliable_get_buf_sequenced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbuffer.html">buffer</a>* reliable_get_buf_sequenced </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer of the next sequential and active entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure from which to retrieve the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the buffer of the entry with the next sequential key ID. If no such entry is present, this function returns NULL. </dd></dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00526">526</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="reliable_8h_source.html#l00071">reliable_entry::active</a>, <a class="el" href="reliable_8h_source.html#l00090">array</a>, <a class="el" href="reliable_8h_source.html#l00076">reliable_entry::buf</a>, <a class="el" href="reliable_8h_source.html#l00074">reliable_entry::packet_id</a>, <a class="el" href="reliable_8h_source.html#l00087">packet_id</a>, and <a class="el" href="reliable_8h_source.html#l00085">size</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l02649">tls_process()</a>.</p>

</div>
</div>
<a id="gab5e5ef6d6fd862187abe76f88b972ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5e5ef6d6fd862187abe76f88b972ee5">&#9670;&nbsp;</a></span>reliable_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buf_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>array_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a reliable structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure to initialize. </td></tr>
    <tr><td class="paramname">buf_size</td><td>The size of the buffers in which packets will be stored. </td></tr>
    <tr><td class="paramname">offset</td><td>The size of reserved space at the beginning of the buffers to allow efficient header prepending. </td></tr>
    <tr><td class="paramname">array_size</td><td>The number of packets that this reliable structure can store simultaneously. </td></tr>
    <tr><td class="paramname">hold</td><td>description </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00309">309</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="buffer_8c_source.html#l00064">alloc_buf()</a>, <a class="el" href="reliable_8h_source.html#l00090">array</a>, <a class="el" href="openvpn_2error_8h_source.html#l00218">ASSERT</a>, <a class="el" href="reliable_8h_source.html#l00076">reliable_entry::buf</a>, <a class="el" href="buffer_8h_source.html#l00196">buf_init</a>, <a class="el" href="openvpn_2basic_8h_source.html#l00033">CLEAR</a>, <a class="el" href="reliable_8h_source.html#l00089">hold</a>, <a class="el" href="buffer_8h_source.html#l00064">buffer::offset</a>, <a class="el" href="reliable_8h_source.html#l00088">offset</a>, <a class="el" href="reliable_8h_source.html#l00051">RELIABLE_CAPACITY</a>, and <a class="el" href="reliable_8h_source.html#l00085">size</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l00916">key_state_init()</a>.</p>

</div>
</div>
<a id="ga2689b44850ce41cc2fe1fc7f57657eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2689b44850ce41cc2fe1fc7f57657eb4">&#9670;&nbsp;</a></span>reliable_mark_active_incoming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_mark_active_incoming </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a>&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the reliable entry associated with the given buffer as active incoming. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure associated with this packet. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer into which the packet has been copied. </td></tr>
    <tr><td class="paramname">pid</td><td>The packet's packet ID. </td></tr>
    <tr><td class="paramname">opcode</td><td>The packet's opcode. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00664">664</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="reliable_8h_source.html#l00071">reliable_entry::active</a>, <a class="el" href="reliable_8h_source.html#l00090">array</a>, <a class="el" href="openvpn_2error_8h_source.html#l00218">ASSERT</a>, <a class="el" href="reliable_8h_source.html#l00076">reliable_entry::buf</a>, <a class="el" href="errlevel_8h_source.html#l00159">D_REL_DEBUG</a>, <a class="el" href="openvpn_2error_8h_source.html#l00171">dmsg</a>, <a class="el" href="reliable_8h_source.html#l00073">reliable_entry::next_try</a>, <a class="el" href="reliable_8h_source.html#l00075">reliable_entry::opcode</a>, <a class="el" href="reliable_8h_source.html#l00074">reliable_entry::packet_id</a>, <a class="el" href="reliable_8h_source.html#l00087">packet_id</a>, <a class="el" href="packet__id_8h_source.html#l00095">packet_id_format</a>, <a class="el" href="reliable_8c_source.html#l00100">reliable_pid_min()</a>, <a class="el" href="reliable_8h_source.html#l00085">size</a>, and <a class="el" href="reliable_8h_source.html#l00072">reliable_entry::timeout</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l03303">tls_pre_decrypt()</a>.</p>

</div>
</div>
<a id="ga2c03b5ae47fe72dbf4fe16f11ea1c091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c03b5ae47fe72dbf4fe16f11ea1c091">&#9670;&nbsp;</a></span>reliable_mark_active_outgoing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_mark_active_outgoing </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the reliable entry associated with the given buffer as active outgoing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure for handling this VPN tunnel's outgoing packets. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer previously returned by <code><a class="el" href="group__reliable.html#gaa15b0672f4ddd65d55194ed5bde0e1c8" title="Get the buffer of free reliable entry and check whether the outgoing acknowledgment sequence is still...">reliable_get_buf_output_sequenced()</a></code> into which the packet has been copied. </td></tr>
    <tr><td class="paramname">opcode</td><td>The packet's opcode. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00696">696</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="reliable_8h_source.html#l00071">reliable_entry::active</a>, <a class="el" href="reliable_8h_source.html#l00090">array</a>, <a class="el" href="openvpn_2error_8h_source.html#l00218">ASSERT</a>, <a class="el" href="reliable_8h_source.html#l00076">reliable_entry::buf</a>, <a class="el" href="buffer_8h_source.html#l00685">buf_write_prepend()</a>, <a class="el" href="errlevel_8h_source.html#l00159">D_REL_DEBUG</a>, <a class="el" href="openvpn_2error_8h_source.html#l00171">dmsg</a>, <a class="el" href="packet__id_8h_source.html#l00061">htonpid</a>, <a class="el" href="reliable_8h_source.html#l00086">initial_timeout</a>, <a class="el" href="reliable_8h_source.html#l00073">reliable_entry::next_try</a>, <a class="el" href="reliable_8h_source.html#l00075">reliable_entry::opcode</a>, <a class="el" href="reliable_8h_source.html#l00074">reliable_entry::packet_id</a>, <a class="el" href="reliable_8h_source.html#l00087">packet_id</a>, <a class="el" href="packet__id_8h_source.html#l00095">packet_id_format</a>, <a class="el" href="reliable_8h_source.html#l00085">size</a>, and <a class="el" href="reliable_8h_source.html#l00072">reliable_entry::timeout</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l02649">tls_process()</a>.</p>

</div>
</div>
<a id="ga5c51920665fa9c34f082dd7aa6ce0e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c51920665fa9c34f082dd7aa6ce0e55">&#9670;&nbsp;</a></span>reliable_mark_deleted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_mark_deleted </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inc_pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an entry from a reliable structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure associated with the given buffer. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer of the reliable entry which is to be removed. </td></tr>
    <tr><td class="paramname">inc_pid</td><td>If true, the reliable structure's packet ID counter will be incremented. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00723">723</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="reliable_8h_source.html#l00071">reliable_entry::active</a>, <a class="el" href="reliable_8h_source.html#l00090">array</a>, <a class="el" href="openvpn_2error_8h_source.html#l00218">ASSERT</a>, <a class="el" href="reliable_8h_source.html#l00076">reliable_entry::buf</a>, <a class="el" href="reliable_8h_source.html#l00074">reliable_entry::packet_id</a>, <a class="el" href="reliable_8h_source.html#l00087">packet_id</a>, and <a class="el" href="reliable_8h_source.html#l00085">size</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l02649">tls_process()</a>.</p>

</div>
</div>
<a id="ga907fd32837c50b4266eb5db1c56f9b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga907fd32837c50b4266eb5db1c56f9b13">&#9670;&nbsp;</a></span>reliable_not_replay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool reliable_not_replay </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that a received packet's ID is not a replay. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure for handling this VPN tunnel's received packets. </td></tr>
    <tr><td class="paramname">id</td><td>The packet ID of the received packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if the packet ID is not a replay. </li>
<li>False, if the packet ID is a replay. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00426">426</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="reliable_8h_source.html#l00071">reliable_entry::active</a>, <a class="el" href="reliable_8h_source.html#l00090">array</a>, <a class="el" href="errlevel_8h_source.html#l00159">D_REL_DEBUG</a>, <a class="el" href="openvpn_2error_8h_source.html#l00171">dmsg</a>, <a class="el" href="buffer_8h_source.html#l01032">gc_free()</a>, <a class="el" href="buffer_8h_source.html#l01024">gc_new()</a>, <a class="el" href="reliable_8h_source.html#l00074">reliable_entry::packet_id</a>, <a class="el" href="reliable_8h_source.html#l00087">packet_id</a>, <a class="el" href="packet__id_8h_source.html#l00095">packet_id_format</a>, <a class="el" href="reliable_8c_source.html#l00100">reliable_pid_min()</a>, <a class="el" href="reliable_8c_source.html#l00388">reliable_print_ids()</a>, and <a class="el" href="reliable_8h_source.html#l00085">size</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l03303">tls_pre_decrypt()</a>.</p>

</div>
</div>
<a id="ga14cb4395f780502ae9edbe6d3f90aec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14cb4395f780502ae9edbe6d3f90aec5">&#9670;&nbsp;</a></span>reliable_schedule_now()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_schedule_now </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reschedule all entries of a reliable structure to be ready for (re)sending immediately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure of which the entries should be modified. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00608">608</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="reliable_8h_source.html#l00071">reliable_entry::active</a>, <a class="el" href="reliable_8h_source.html#l00090">array</a>, <a class="el" href="errlevel_8h_source.html#l00159">D_REL_DEBUG</a>, <a class="el" href="openvpn_2error_8h_source.html#l00171">dmsg</a>, <a class="el" href="reliable_8h_source.html#l00089">hold</a>, <a class="el" href="reliable_8h_source.html#l00086">initial_timeout</a>, <a class="el" href="reliable_8h_source.html#l00073">reliable_entry::next_try</a>, <a class="el" href="otime_8c_source.html#l00036">now</a>, <a class="el" href="reliable_8h_source.html#l00085">size</a>, and <a class="el" href="reliable_8h_source.html#l00072">reliable_entry::timeout</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l03303">tls_pre_decrypt()</a>.</p>

</div>
</div>
<a id="gaebcf7ae7a144f32b55c9af5c51121ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebcf7ae7a144f32b55c9af5c51121ec1">&#9670;&nbsp;</a></span>reliable_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbuffer.html">buffer</a>* reliable_send </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>opcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next packet to send to the remote peer. </p>
<p>This function looks for the active entry ready for (re)sending with the lowest packet ID, and returns the buffer associated with it. This function also resets the timeout after which that entry will become ready for resending again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure to check. </td></tr>
    <tr><td class="paramname">opcode</td><td>A pointer to an integer in which this function will store the opcode of the next packet to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the buffer of the next entry to be sent, or NULL if there are no entries ready for (re)sending present in the reliable structure. If a valid pointer is returned, then <em>opcode</em> will point to the opcode of that packet. </dd></dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00570">570</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="reliable_8h_source.html#l00071">reliable_entry::active</a>, <a class="el" href="reliable_8h_source.html#l00090">array</a>, <a class="el" href="reliable_8h_source.html#l00076">reliable_entry::buf</a>, <a class="el" href="errlevel_8h_source.html#l00159">D_REL_DEBUG</a>, <a class="el" href="openvpn_2error_8h_source.html#l00171">dmsg</a>, <a class="el" href="buffer_8h_source.html#l00066">buffer::len</a>, <a class="el" href="reliable_8h_source.html#l00073">reliable_entry::next_try</a>, <a class="el" href="otime_8c_source.html#l00036">now</a>, <a class="el" href="reliable_8h_source.html#l00075">reliable_entry::opcode</a>, <a class="el" href="reliable_8h_source.html#l00074">reliable_entry::packet_id</a>, <a class="el" href="packet__id_8h_source.html#l00095">packet_id_format</a>, <a class="el" href="reliable_8c_source.html#l00100">reliable_pid_min()</a>, <a class="el" href="reliable_8h_source.html#l00085">size</a>, and <a class="el" href="reliable_8h_source.html#l00072">reliable_entry::timeout</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l02649">tls_process()</a>.</p>

</div>
</div>
<a id="ga6a9f750ec286ebf613f115757ce197d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a9f750ec286ebf613f115757ce197d0">&#9670;&nbsp;</a></span>reliable_send_purge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reliable_send_purge </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structreliable__ack.html">reliable_ack</a> *&#160;</td>
          <td class="paramname"><em>ack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove acknowledged packets from a reliable structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure storing sent packets. </td></tr>
    <tr><td class="paramname">ack</td><td>The acknowledgment structure containing received acknowledgments. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00355">355</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="reliable_8h_source.html#l00071">reliable_entry::active</a>, <a class="el" href="reliable_8h_source.html#l00090">array</a>, <a class="el" href="errlevel_8h_source.html#l00159">D_REL_DEBUG</a>, <a class="el" href="openvpn_2error_8h_source.html#l00171">dmsg</a>, <a class="el" href="reliable_8h_source.html#l00061">reliable_ack::len</a>, <a class="el" href="errlevel_8h_source.html#l00055">M_INFO</a>, <a class="el" href="openvpn_2error_8h_source.html#l00170">msg</a>, <a class="el" href="reliable_8h_source.html#l00073">reliable_entry::next_try</a>, <a class="el" href="otime_8c_source.html#l00036">now</a>, <a class="el" href="reliable_8h_source.html#l00062">reliable_ack::packet_id</a>, <a class="el" href="reliable_8h_source.html#l00074">reliable_entry::packet_id</a>, <a class="el" href="packet__id_8h_source.html#l00095">packet_id_format</a>, and <a class="el" href="reliable_8h_source.html#l00085">size</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l03303">tls_pre_decrypt()</a>.</p>

</div>
</div>
<a id="ga9e8edfca42338da6da6ccb3fd1849dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e8edfca42338da6da6ccb3fd1849dca">&#9670;&nbsp;</a></span>reliable_send_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_8h.html#a3d8621f960ada51a5ad9ff181730481a">interval_t</a> reliable_send_timeout </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determined how many seconds until the earliest resend should be attempted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structured to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interval in seconds until the earliest resend attempt of the outgoing packets stored in the <em>rel</em> reliable structure. If the next time for attempting resending of one or more packets has already passed, this function will return 0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00627">627</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="reliable_8h_source.html#l00071">reliable_entry::active</a>, <a class="el" href="reliable_8h_source.html#l00090">array</a>, <a class="el" href="common_8h_source.html#l00050">BIG_TIMEOUT</a>, <a class="el" href="errlevel_8h_source.html#l00159">D_REL_DEBUG</a>, <a class="el" href="openvpn_2error_8h_source.html#l00171">dmsg</a>, <a class="el" href="buffer_8h_source.html#l01032">gc_free()</a>, <a class="el" href="buffer_8h_source.html#l01024">gc_new()</a>, <a class="el" href="integer_8h_source.html#l00057">min_int()</a>, <a class="el" href="reliable_8h_source.html#l00073">reliable_entry::next_try</a>, <a class="el" href="otime_8c_source.html#l00036">now</a>, <a class="el" href="reliable_8c_source.html#l00388">reliable_print_ids()</a>, and <a class="el" href="reliable_8h_source.html#l00085">size</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l02649">tls_process()</a>.</p>

</div>
</div>
<a id="ga5950f411ad409250922e2f792aecb61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5950f411ad409250922e2f792aecb61f">&#9670;&nbsp;</a></span>reliable_set_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void reliable_set_timeout </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="common_8h.html#a3d8621f960ada51a5ad9ff181730481a">interval_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="reliable_8h_source.html#l00460">460</a> of file <a class="el" href="reliable_8h_source.html">reliable.h</a>.</p>

<p class="reference">References <a class="el" href="reliable_8h_source.html#l00086">initial_timeout</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l00916">key_state_init()</a>.</p>

</div>
</div>
<a id="gad2d6e3bde9beced3d69bbba652730439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2d6e3bde9beced3d69bbba652730439">&#9670;&nbsp;</a></span>reliable_wont_break_sequentiality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool reliable_wont_break_sequentiality </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structreliable.html">reliable</a> *&#160;</td>
          <td class="paramname"><em>rel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="packet__id_8h.html#a345f753b1c6ea20d24409e769aadb7e6">packet_id_type</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that a received packet's ID can safely be stored in the reliable structure's processing window. </p>
<p>This function checks the difference between the received packet's ID and the lowest non-acknowledged packet ID in the given reliable structure. If that difference is larger than the total number of packets which can be stored, then this packet cannot be stored safely, because the reliable structure could possibly fill up without leaving room for all intervening packets. In that case, this received packet could break the reliable structure's sequentiality, and must therefore be discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>The reliable structure for handling this VPN tunnel's received packets. </td></tr>
    <tr><td class="paramname">id</td><td>The packet ID of the received packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if the packet can safely be stored. </li>
<li>False, if the packet does not fit safely in the reliable structure's processing window. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="reliable_8c_source.html#l00453">453</a> of file <a class="el" href="reliable_8c_source.html">reliable.c</a>.</p>

<p class="reference">References <a class="el" href="errlevel_8h_source.html#l00159">D_REL_DEBUG</a>, <a class="el" href="errlevel_8h_source.html#l00121">D_REL_LOW</a>, <a class="el" href="openvpn_2error_8h_source.html#l00171">dmsg</a>, <a class="el" href="buffer_8h_source.html#l01032">gc_free()</a>, <a class="el" href="buffer_8h_source.html#l01024">gc_new()</a>, <a class="el" href="reliable_8h_source.html#l00087">packet_id</a>, <a class="el" href="packet__id_8h_source.html#l00095">packet_id_format</a>, <a class="el" href="reliable_8c_source.html#l00074">reliable_pid_in_range2()</a>, <a class="el" href="reliable_8c_source.html#l00388">reliable_print_ids()</a>, and <a class="el" href="reliable_8h_source.html#l00085">size</a>.</p>

<p class="reference">Referenced by <a class="el" href="ssl_8c_source.html#l03303">tls_pre_decrypt()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
