<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVPN: Fragmentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVPN
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Fragmentation</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfragment.html">fragment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for reassembling one incoming fragmented packet.  <a href="structfragment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfragment__list.html">fragment_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of fragment structures for reassembling multiple incoming packets concurrently.  <a href="structfragment__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfragment__master.html">fragment_master</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fragmentation and reassembly state for one VPN tunnel instance.  <a href="structfragment__master.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac70c6ff35b69110fa3f80d39cb31095a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#gac70c6ff35b69110fa3f80d39cb31095a">N_FRAG_BUF</a>&#160;&#160;&#160;25</td></tr>
<tr class="memdesc:gac70c6ff35b69110fa3f80d39cb31095a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of packet buffers for reassembling incoming fragmented packets.  <a href="group__fragmentation.html#gac70c6ff35b69110fa3f80d39cb31095a">More...</a><br /></td></tr>
<tr class="separator:gac70c6ff35b69110fa3f80d39cb31095a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0734e22cc0aead1c3f72118a37fd6954"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#ga0734e22cc0aead1c3f72118a37fd6954">FRAG_TTL_SEC</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:ga0734e22cc0aead1c3f72118a37fd6954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time-to-live in seconds for a fragment.  <a href="group__fragmentation.html#ga0734e22cc0aead1c3f72118a37fd6954">More...</a><br /></td></tr>
<tr class="separator:ga0734e22cc0aead1c3f72118a37fd6954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac80975ec6bf6ea0417f924b37fb56fdc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#gac80975ec6bf6ea0417f924b37fb56fdc">FRAG_WAKEUP_INTERVAL</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:gac80975ec6bf6ea0417f924b37fb56fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interval in seconds between calls to wakeup code.  <a href="group__fragmentation.html#gac80975ec6bf6ea0417f924b37fb56fdc">More...</a><br /></td></tr>
<tr class="separator:gac80975ec6bf6ea0417f924b37fb56fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacf00a549c0d55a864584b128cd1d1927"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#gacf00a549c0d55a864584b128cd1d1927">fragment_wakeup</a> (struct <a class="el" href="structfragment__master.html">fragment_master</a> *f, struct <a class="el" href="structframe.html">frame</a> *<a class="el" href="structframe.html">frame</a>)</td></tr>
<tr class="separator:gacf00a549c0d55a864584b128cd1d1927"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Fragment header</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp0de59534d97f2e219f5b65054199c2da"></a> </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Add description of fragment header format.</dd></dl>
</td></tr>
<tr class="memitem:ga69167a8c3dbf318d7ecfd4abc888044e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="config-msvc_8h.html#a6eb1e68cc391dd753bc8ce896dbb8315">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#ga69167a8c3dbf318d7ecfd4abc888044e">fragment_header_type</a></td></tr>
<tr class="memdesc:ga69167a8c3dbf318d7ecfd4abc888044e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fragmentation information is stored in a 32-bit packet header.  <a href="group__fragmentation.html#ga69167a8c3dbf318d7ecfd4abc888044e">More...</a><br /></td></tr>
<tr class="separator:ga69167a8c3dbf318d7ecfd4abc888044e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01f33477e16b4dc5aaa209e6c19d75fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#ga01f33477e16b4dc5aaa209e6c19d75fd">hton_fragment_header_type</a>(x)&#160;&#160;&#160;htonl(x)</td></tr>
<tr class="memdesc:ga01f33477e16b4dc5aaa209e6c19d75fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a fragment_header_type from host to network order.  <a href="group__fragmentation.html#ga01f33477e16b4dc5aaa209e6c19d75fd">More...</a><br /></td></tr>
<tr class="separator:ga01f33477e16b4dc5aaa209e6c19d75fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaaf50d07d04564c86229dd4da126c25"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#gaeaaf50d07d04564c86229dd4da126c25">ntoh_fragment_header_type</a>(x)&#160;&#160;&#160;ntohl(x)</td></tr>
<tr class="memdesc:gaeaaf50d07d04564c86229dd4da126c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <code>fragment_header_type</code> from network to host order.  <a href="group__fragmentation.html#gaeaaf50d07d04564c86229dd4da126c25">More...</a><br /></td></tr>
<tr class="separator:gaeaaf50d07d04564c86229dd4da126c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadb98fb20038d668245f4b5e36f0e1f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#gaadb98fb20038d668245f4b5e36f0e1f2">FRAG_TYPE_MASK</a>&#160;&#160;&#160;0x00000003</td></tr>
<tr class="memdesc:gaadb98fb20038d668245f4b5e36f0e1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit mask for fragment type info.  <a href="group__fragmentation.html#gaadb98fb20038d668245f4b5e36f0e1f2">More...</a><br /></td></tr>
<tr class="separator:gaadb98fb20038d668245f4b5e36f0e1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c21b2617660c826f3d500246d52b7d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#ga6c21b2617660c826f3d500246d52b7d1">FRAG_TYPE_SHIFT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga6c21b2617660c826f3d500246d52b7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit shift for fragment type info.  <a href="group__fragmentation.html#ga6c21b2617660c826f3d500246d52b7d1">More...</a><br /></td></tr>
<tr class="separator:ga6c21b2617660c826f3d500246d52b7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3660951c032f02c8dcd6ccdab37e5f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#gaa3660951c032f02c8dcd6ccdab37e5f2">FRAG_WHOLE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gaa3660951c032f02c8dcd6ccdab37e5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fragment type indicating packet is whole.  <a href="group__fragmentation.html#gaa3660951c032f02c8dcd6ccdab37e5f2">More...</a><br /></td></tr>
<tr class="separator:gaa3660951c032f02c8dcd6ccdab37e5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf0eca0df84e5d201ef805f5bf5eb5f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#gadf0eca0df84e5d201ef805f5bf5eb5f6">FRAG_YES_NOTLAST</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gadf0eca0df84e5d201ef805f5bf5eb5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fragment type indicating packet is part of a fragmented packet, but not the last part in the sequence.  <a href="group__fragmentation.html#gadf0eca0df84e5d201ef805f5bf5eb5f6">More...</a><br /></td></tr>
<tr class="separator:gadf0eca0df84e5d201ef805f5bf5eb5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95d0b14b610983de2c4992b3090e575b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#ga95d0b14b610983de2c4992b3090e575b">FRAG_YES_LAST</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga95d0b14b610983de2c4992b3090e575b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fragment type indicating packet is the last part in the sequence of parts.  <a href="group__fragmentation.html#ga95d0b14b610983de2c4992b3090e575b">More...</a><br /></td></tr>
<tr class="separator:ga95d0b14b610983de2c4992b3090e575b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79fcd096ab99879b56b86266b01a7b59"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#ga79fcd096ab99879b56b86266b01a7b59">FRAG_TEST</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:ga79fcd096ab99879b56b86266b01a7b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fragment type not implemented yet.  <a href="group__fragmentation.html#ga79fcd096ab99879b56b86266b01a7b59">More...</a><br /></td></tr>
<tr class="separator:ga79fcd096ab99879b56b86266b01a7b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3effaad37521e90e15f872895425a09f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#ga3effaad37521e90e15f872895425a09f">FRAG_SEQ_ID_MASK</a>&#160;&#160;&#160;0x000000ff</td></tr>
<tr class="memdesc:ga3effaad37521e90e15f872895425a09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit mask for fragment sequence ID.  <a href="group__fragmentation.html#ga3effaad37521e90e15f872895425a09f">More...</a><br /></td></tr>
<tr class="separator:ga3effaad37521e90e15f872895425a09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33fcfec81e6502bd0683d410da2c8a43"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#ga33fcfec81e6502bd0683d410da2c8a43">FRAG_SEQ_ID_SHIFT</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga33fcfec81e6502bd0683d410da2c8a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit shift for fragment sequence ID.  <a href="group__fragmentation.html#ga33fcfec81e6502bd0683d410da2c8a43">More...</a><br /></td></tr>
<tr class="separator:ga33fcfec81e6502bd0683d410da2c8a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3a43cb119381aa8e7747f8be6f6c049"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#gaf3a43cb119381aa8e7747f8be6f6c049">FRAG_ID_MASK</a>&#160;&#160;&#160;0x0000001f</td></tr>
<tr class="memdesc:gaf3a43cb119381aa8e7747f8be6f6c049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit mask for fragment ID.  <a href="group__fragmentation.html#gaf3a43cb119381aa8e7747f8be6f6c049">More...</a><br /></td></tr>
<tr class="separator:gaf3a43cb119381aa8e7747f8be6f6c049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6b49757480dca90db5d906d17f746a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#gaa6b49757480dca90db5d906d17f746a8">FRAG_ID_SHIFT</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:gaa6b49757480dca90db5d906d17f746a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit shift for fragment ID.  <a href="group__fragmentation.html#gaa6b49757480dca90db5d906d17f746a8">More...</a><br /></td></tr>
<tr class="separator:gaa6b49757480dca90db5d906d17f746a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00d4eb7e42c98ad73c5a4fcb9a95234f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#ga00d4eb7e42c98ad73c5a4fcb9a95234f">FRAG_SIZE_MASK</a>&#160;&#160;&#160;0x00003fff</td></tr>
<tr class="memdesc:ga00d4eb7e42c98ad73c5a4fcb9a95234f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit mask for fragment size.  <a href="group__fragmentation.html#ga00d4eb7e42c98ad73c5a4fcb9a95234f">More...</a><br /></td></tr>
<tr class="separator:ga00d4eb7e42c98ad73c5a4fcb9a95234f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbb3b9c37eb42de4e896ca0dfaf616bd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#gafbb3b9c37eb42de4e896ca0dfaf616bd">FRAG_SIZE_SHIFT</a>&#160;&#160;&#160;15</td></tr>
<tr class="memdesc:gafbb3b9c37eb42de4e896ca0dfaf616bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit shift for fragment size.  <a href="group__fragmentation.html#gafbb3b9c37eb42de4e896ca0dfaf616bd">More...</a><br /></td></tr>
<tr class="separator:gafbb3b9c37eb42de4e896ca0dfaf616bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa814cc3bc6de2eb908bdc3065cfcb474"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#gaa814cc3bc6de2eb908bdc3065cfcb474">FRAG_SIZE_ROUND_SHIFT</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:gaa814cc3bc6de2eb908bdc3065cfcb474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit shift for fragment size rounding.  <a href="group__fragmentation.html#gaa814cc3bc6de2eb908bdc3065cfcb474">More...</a><br /></td></tr>
<tr class="separator:gaa814cc3bc6de2eb908bdc3065cfcb474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64d4625277bb54cc9e888f4d2b987070"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#ga64d4625277bb54cc9e888f4d2b987070">FRAG_SIZE_ROUND_MASK</a>&#160;&#160;&#160;((1 &lt;&lt; <a class="el" href="group__fragmentation.html#gaa814cc3bc6de2eb908bdc3065cfcb474">FRAG_SIZE_ROUND_SHIFT</a>) - 1)</td></tr>
<tr class="memdesc:ga64d4625277bb54cc9e888f4d2b987070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit mask for fragment size rounding.  <a href="group__fragmentation.html#ga64d4625277bb54cc9e888f4d2b987070">More...</a><br /></td></tr>
<tr class="separator:ga64d4625277bb54cc9e888f4d2b987070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86ca315ed1280ba7fc2e8e4030e7d194"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#ga86ca315ed1280ba7fc2e8e4030e7d194">FRAG_EXTRA_MASK</a>&#160;&#160;&#160;0x0000ffff</td></tr>
<tr class="memdesc:ga86ca315ed1280ba7fc2e8e4030e7d194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit mask for extra bits.  <a href="group__fragmentation.html#ga86ca315ed1280ba7fc2e8e4030e7d194">More...</a><br /></td></tr>
<tr class="separator:ga86ca315ed1280ba7fc2e8e4030e7d194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93dd54339aed4e498e3c40fc22be90bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#ga93dd54339aed4e498e3c40fc22be90bf">FRAG_EXTRA_SHIFT</a>&#160;&#160;&#160;15</td></tr>
<tr class="memdesc:ga93dd54339aed4e498e3c40fc22be90bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit shift for extra bits.  <a href="group__fragmentation.html#ga93dd54339aed4e498e3c40fc22be90bf">More...</a><br /></td></tr>
<tr class="separator:ga93dd54339aed4e498e3c40fc22be90bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for initialization and cleanup</h2></td></tr>
<tr class="memitem:ga0be982cb04c4e5c3344d8f91323f4d8c"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structfragment__master.html">fragment_master</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#ga0be982cb04c4e5c3344d8f91323f4d8c">fragment_init</a> (struct <a class="el" href="structframe.html">frame</a> *<a class="el" href="structframe.html">frame</a>)</td></tr>
<tr class="memdesc:ga0be982cb04c4e5c3344d8f91323f4d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a <code><a class="el" href="structfragment__master.html" title="Fragmentation and reassembly state for one VPN tunnel instance.">fragment_master</a></code> structure.  <a href="group__fragmentation.html#ga0be982cb04c4e5c3344d8f91323f4d8c">More...</a><br /></td></tr>
<tr class="separator:ga0be982cb04c4e5c3344d8f91323f4d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78eb641be3402b8db31607baba604e62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#ga78eb641be3402b8db31607baba604e62">fragment_frame_init</a> (struct <a class="el" href="structfragment__master.html">fragment_master</a> *f, const struct <a class="el" href="structframe.html">frame</a> *<a class="el" href="structframe.html">frame</a>)</td></tr>
<tr class="memdesc:ga78eb641be3402b8db31607baba604e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate internal packet buffers for a <code><a class="el" href="structfragment__master.html" title="Fragmentation and reassembly state for one VPN tunnel instance.">fragment_master</a></code> structure.  <a href="group__fragmentation.html#ga78eb641be3402b8db31607baba604e62">More...</a><br /></td></tr>
<tr class="separator:ga78eb641be3402b8db31607baba604e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6f7daf38cb2c0edaa6dbdfeabddb826"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#gae6f7daf38cb2c0edaa6dbdfeabddb826">fragment_free</a> (struct <a class="el" href="structfragment__master.html">fragment_master</a> *f)</td></tr>
<tr class="memdesc:gae6f7daf38cb2c0edaa6dbdfeabddb826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a <code><a class="el" href="structfragment__master.html" title="Fragmentation and reassembly state for one VPN tunnel instance.">fragment_master</a></code> structure and its internal packet buffers.  <a href="group__fragmentation.html#gae6f7daf38cb2c0edaa6dbdfeabddb826">More...</a><br /></td></tr>
<tr class="separator:gae6f7daf38cb2c0edaa6dbdfeabddb826"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for processing packets received from a remote OpenVPN peer</h2></td></tr>
<tr class="memitem:gaa1048bcf1d77edd2762193d3c26e5a63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#gaa1048bcf1d77edd2762193d3c26e5a63">fragment_incoming</a> (struct <a class="el" href="structfragment__master.html">fragment_master</a> *f, struct <a class="el" href="structbuffer.html">buffer</a> *buf, const struct <a class="el" href="structframe.html">frame</a> *<a class="el" href="structframe.html">frame</a>)</td></tr>
<tr class="memdesc:gaa1048bcf1d77edd2762193d3c26e5a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process an incoming packet, which may or may not be fragmented.  <a href="group__fragmentation.html#gaa1048bcf1d77edd2762193d3c26e5a63">More...</a><br /></td></tr>
<tr class="separator:gaa1048bcf1d77edd2762193d3c26e5a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for processing packets to be sent to a remote OpenVPN peer</h2></td></tr>
<tr class="memitem:ga8d431d13746c625db07ffbef8fdb4b63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#ga8d431d13746c625db07ffbef8fdb4b63">fragment_outgoing</a> (struct <a class="el" href="structfragment__master.html">fragment_master</a> *f, struct <a class="el" href="structbuffer.html">buffer</a> *buf, const struct <a class="el" href="structframe.html">frame</a> *<a class="el" href="structframe.html">frame</a>)</td></tr>
<tr class="memdesc:ga8d431d13746c625db07ffbef8fdb4b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process an outgoing packet, which may or may not need to be fragmented.  <a href="group__fragmentation.html#ga8d431d13746c625db07ffbef8fdb4b63">More...</a><br /></td></tr>
<tr class="separator:ga8d431d13746c625db07ffbef8fdb4b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafee718405669b72a316b31225da38485"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#gafee718405669b72a316b31225da38485">fragment_ready_to_send</a> (struct <a class="el" href="structfragment__master.html">fragment_master</a> *f, struct <a class="el" href="structbuffer.html">buffer</a> *buf, const struct <a class="el" href="structframe.html">frame</a> *<a class="el" href="structframe.html">frame</a>)</td></tr>
<tr class="memdesc:gafee718405669b72a316b31225da38485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether outgoing fragments are ready to be send, and if so make one available.  <a href="group__fragmentation.html#gafee718405669b72a316b31225da38485">More...</a><br /></td></tr>
<tr class="separator:gafee718405669b72a316b31225da38485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e459710a8c1f5d5f8446d92106119b0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#ga7e459710a8c1f5d5f8446d92106119b0">fragment_outgoing_defined</a> (struct <a class="el" href="structfragment__master.html">fragment_master</a> *f)</td></tr>
<tr class="memdesc:ga7e459710a8c1f5d5f8446d92106119b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a <code><a class="el" href="structfragment__master.html" title="Fragmentation and reassembly state for one VPN tunnel instance.">fragment_master</a></code> structure contains fragments ready to be sent.  <a href="group__fragmentation.html#ga7e459710a8c1f5d5f8446d92106119b0">More...</a><br /></td></tr>
<tr class="separator:ga7e459710a8c1f5d5f8446d92106119b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Functions for regular housekeeping</h2></td></tr>
<tr class="memitem:ga6e041de3847f4dceb3d17413d9fb6cd8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fragmentation.html#ga6e041de3847f4dceb3d17413d9fb6cd8">fragment_housekeeping</a> (struct <a class="el" href="structfragment__master.html">fragment_master</a> *f, struct <a class="el" href="structframe.html">frame</a> *<a class="el" href="structframe.html">frame</a>, struct timeval *tv)</td></tr>
<tr class="memdesc:ga6e041de3847f4dceb3d17413d9fb6cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform housekeeping of a <code><a class="el" href="structfragment__master.html" title="Fragmentation and reassembly state for one VPN tunnel instance.">fragment_master</a></code> structure.  <a href="group__fragmentation.html#ga6e041de3847f4dceb3d17413d9fb6cd8">More...</a><br /></td></tr>
<tr class="separator:ga6e041de3847f4dceb3d17413d9fb6cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga86ca315ed1280ba7fc2e8e4030e7d194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86ca315ed1280ba7fc2e8e4030e7d194">&#9670;&nbsp;</a></span>FRAG_EXTRA_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FRAG_EXTRA_MASK&#160;&#160;&#160;0x0000ffff</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit mask for extra bits. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00252">252</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="ga93dd54339aed4e498e3c40fc22be90bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93dd54339aed4e498e3c40fc22be90bf">&#9670;&nbsp;</a></span>FRAG_EXTRA_SHIFT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FRAG_EXTRA_SHIFT&#160;&#160;&#160;15</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit shift for extra bits. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00254">254</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="gaf3a43cb119381aa8e7747f8be6f6c049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3a43cb119381aa8e7747f8be6f6c049">&#9670;&nbsp;</a></span>FRAG_ID_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FRAG_ID_MASK&#160;&#160;&#160;0x0000001f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit mask for fragment ID. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00225">225</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="gaa6b49757480dca90db5d906d17f746a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6b49757480dca90db5d906d17f746a8">&#9670;&nbsp;</a></span>FRAG_ID_SHIFT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FRAG_ID_SHIFT&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit shift for fragment ID. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00227">227</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="ga3effaad37521e90e15f872895425a09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3effaad37521e90e15f872895425a09f">&#9670;&nbsp;</a></span>FRAG_SEQ_ID_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FRAG_SEQ_ID_MASK&#160;&#160;&#160;0x000000ff</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit mask for fragment sequence ID. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00221">221</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="ga33fcfec81e6502bd0683d410da2c8a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33fcfec81e6502bd0683d410da2c8a43">&#9670;&nbsp;</a></span>FRAG_SEQ_ID_SHIFT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FRAG_SEQ_ID_SHIFT&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit shift for fragment sequence ID. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00223">223</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="ga00d4eb7e42c98ad73c5a4fcb9a95234f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00d4eb7e42c98ad73c5a4fcb9a95234f">&#9670;&nbsp;</a></span>FRAG_SIZE_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FRAG_SIZE_MASK&#160;&#160;&#160;0x00003fff</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit mask for fragment size. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00239">239</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="ga64d4625277bb54cc9e888f4d2b987070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64d4625277bb54cc9e888f4d2b987070">&#9670;&nbsp;</a></span>FRAG_SIZE_ROUND_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FRAG_SIZE_ROUND_MASK&#160;&#160;&#160;((1 &lt;&lt; <a class="el" href="group__fragmentation.html#gaa814cc3bc6de2eb908bdc3065cfcb474">FRAG_SIZE_ROUND_SHIFT</a>) - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit mask for fragment size rounding. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00244">244</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="gaa814cc3bc6de2eb908bdc3065cfcb474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa814cc3bc6de2eb908bdc3065cfcb474">&#9670;&nbsp;</a></span>FRAG_SIZE_ROUND_SHIFT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FRAG_SIZE_ROUND_SHIFT&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit shift for fragment size rounding. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00243">243</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="gafbb3b9c37eb42de4e896ca0dfaf616bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbb3b9c37eb42de4e896ca0dfaf616bd">&#9670;&nbsp;</a></span>FRAG_SIZE_SHIFT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FRAG_SIZE_SHIFT&#160;&#160;&#160;15</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit shift for fragment size. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00241">241</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="ga79fcd096ab99879b56b86266b01a7b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79fcd096ab99879b56b86266b01a7b59">&#9670;&nbsp;</a></span>FRAG_TEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FRAG_TEST&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fragment type not implemented yet. </p>
<p>In the future might be used as a control packet for establishing MTU size. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00216">216</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="ga0734e22cc0aead1c3f72118a37fd6954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0734e22cc0aead1c3f72118a37fd6954">&#9670;&nbsp;</a></span>FRAG_TTL_SEC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FRAG_TTL_SEC&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time-to-live in seconds for a fragment. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00054">54</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="gaadb98fb20038d668245f4b5e36f0e1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadb98fb20038d668245f4b5e36f0e1f2">&#9670;&nbsp;</a></span>FRAG_TYPE_MASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FRAG_TYPE_MASK&#160;&#160;&#160;0x00000003</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit mask for fragment type info. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00204">204</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="ga6c21b2617660c826f3d500246d52b7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c21b2617660c826f3d500246d52b7d1">&#9670;&nbsp;</a></span>FRAG_TYPE_SHIFT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FRAG_TYPE_SHIFT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit shift for fragment type info. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00206">206</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="gac80975ec6bf6ea0417f924b37fb56fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac80975ec6bf6ea0417f924b37fb56fdc">&#9670;&nbsp;</a></span>FRAG_WAKEUP_INTERVAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FRAG_WAKEUP_INTERVAL&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interval in seconds between calls to wakeup code. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00057">57</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="gaa3660951c032f02c8dcd6ccdab37e5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3660951c032f02c8dcd6ccdab37e5f2">&#9670;&nbsp;</a></span>FRAG_WHOLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FRAG_WHOLE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fragment type indicating packet is whole. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00208">208</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="ga95d0b14b610983de2c4992b3090e575b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95d0b14b610983de2c4992b3090e575b">&#9670;&nbsp;</a></span>FRAG_YES_LAST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FRAG_YES_LAST&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fragment type indicating packet is the last part in the sequence of parts. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00213">213</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="gadf0eca0df84e5d201ef805f5bf5eb5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf0eca0df84e5d201ef805f5bf5eb5f6">&#9670;&nbsp;</a></span>FRAG_YES_NOTLAST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FRAG_YES_NOTLAST&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fragment type indicating packet is part of a fragmented packet, but not the last part in the sequence. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00210">210</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="ga01f33477e16b4dc5aaa209e6c19d75fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01f33477e16b4dc5aaa209e6c19d75fd">&#9670;&nbsp;</a></span>hton_fragment_header_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hton_fragment_header_type</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;htonl(x)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a fragment_header_type from host to network order. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00194">194</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="gac70c6ff35b69110fa3f80d39cb31095a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac70c6ff35b69110fa3f80d39cb31095a">&#9670;&nbsp;</a></span>N_FRAG_BUF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define N_FRAG_BUF&#160;&#160;&#160;25</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of packet buffers for reassembling incoming fragmented packets. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00049">49</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<a id="gaeaaf50d07d04564c86229dd4da126c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaaf50d07d04564c86229dd4da126c25">&#9670;&nbsp;</a></span>ntoh_fragment_header_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ntoh_fragment_header_type</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;ntohl(x)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <code>fragment_header_type</code> from network to host order. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00199">199</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga69167a8c3dbf318d7ecfd4abc888044e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69167a8c3dbf318d7ecfd4abc888044e">&#9670;&nbsp;</a></span>fragment_header_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="config-msvc_8h.html#a6eb1e68cc391dd753bc8ce896dbb8315">uint32_t</a> <a class="el" href="group__fragmentation.html#ga69167a8c3dbf318d7ecfd4abc888044e">fragment_header_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fragmentation information is stored in a 32-bit packet header. </p>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00190">190</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga78eb641be3402b8db31607baba604e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78eb641be3402b8db31607baba604e62">&#9670;&nbsp;</a></span>fragment_frame_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fragment_frame_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfragment__master.html">fragment_master</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structframe.html">frame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate internal packet buffers for a <code><a class="el" href="structfragment__master.html" title="Fragmentation and reassembly state for one VPN tunnel instance.">fragment_master</a></code> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- The <code><a class="el" href="structfragment__master.html" title="Fragmentation and reassembly state for one VPN tunnel instance.">fragment_master</a></code> structure for which to allocate the internal buffers. </td></tr>
    <tr><td class="paramname">frame</td><td>- The packet geometry parameters for this VPN tunnel, used to determine how much memory to allocate for each packet buffer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fragment_8c_source.html#l00127">127</a> of file <a class="el" href="fragment_8c_source.html">fragment.c</a>.</p>

<p class="reference">References <a class="el" href="buffer_8c_source.html#l00064">alloc_buf()</a>, <a class="el" href="mtu_8h_source.html#l00194">BUF_SIZE</a>, <a class="el" href="http-client_8py_source.html#l00006">http-client::f</a>, and <a class="el" href="fragment_8c_source.html#l00043">fragment_list_buf_init()</a>.</p>

<p class="reference">Referenced by <a class="el" href="init_8c_source.html#l03402">do_init_fragment()</a>.</p>

</div>
</div>
<a id="gae6f7daf38cb2c0edaa6dbdfeabddb826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6f7daf38cb2c0edaa6dbdfeabddb826">&#9670;&nbsp;</a></span>fragment_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fragment_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfragment__master.html">fragment_master</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a <code><a class="el" href="structfragment__master.html" title="Fragmentation and reassembly state for one VPN tunnel instance.">fragment_master</a></code> structure and its internal packet buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- The <code><a class="el" href="structfragment__master.html" title="Fragmentation and reassembly state for one VPN tunnel instance.">fragment_master</a></code> structure to free. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fragment_8c_source.html#l00118">118</a> of file <a class="el" href="fragment_8c_source.html">fragment.c</a>.</p>

<p class="reference">References <a class="el" href="http-client_8py_source.html#l00006">http-client::f</a>, <a class="el" href="fragment_8c_source.html#l00053">fragment_list_buf_free()</a>, and <a class="el" href="buffer_8c_source.html#l00185">free_buf()</a>.</p>

<p class="reference">Referenced by <a class="el" href="init_8c_source.html#l03705">do_close_fragment()</a>.</p>

</div>
</div>
<a id="ga6e041de3847f4dceb3d17413d9fb6cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e041de3847f4dceb3d17413d9fb6cd8">&#9670;&nbsp;</a></span>fragment_housekeeping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fragment_housekeeping </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfragment__master.html">fragment_master</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structframe.html">frame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>tv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform housekeeping of a <code><a class="el" href="structfragment__master.html" title="Fragmentation and reassembly state for one VPN tunnel instance.">fragment_master</a></code> structure. </p>
<p>Housekeeping includes scanning incoming packet reassembly buffers for packets which have not yet been reassembled completely but are already older than their time-to-live.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- The <code><a class="el" href="structfragment__master.html" title="Fragmentation and reassembly state for one VPN tunnel instance.">fragment_master</a></code> structure for this VPN tunnel. </td></tr>
    <tr><td class="paramname">frame</td><td>- The packet geometry parameters for this VPN tunnel. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00467">467</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

<p class="reference">References <a class="el" href="http-client_8py_source.html#l00006">http-client::f</a>, and <a class="el" href="fragment_8c_source.html#l00434">fragment_wakeup()</a>.</p>

<p class="reference">Referenced by <a class="el" href="forward_8c_source.html#l00520">check_fragment()</a>.</p>

</div>
</div>
<a id="gaa1048bcf1d77edd2762193d3c26e5a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1048bcf1d77edd2762193d3c26e5a63">&#9670;&nbsp;</a></span>fragment_incoming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fragment_incoming </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfragment__master.html">fragment_master</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structframe.html">frame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process an incoming packet, which may or may not be fragmented. </p>
<p>This function inspects the fragmentation header of the incoming packet and processes the packet accordingly. Depending on the fragment type bits (<code>FRAG_TYPE_MASK</code> and <code>FRAG_TYPE_SHIFT</code>) the packet is processed in the following ways:</p><ul>
<li><code>FRAG_WHOLE:</code> the packet is not fragmented, and this function does not modify its contents, except for removing the fragmentation header.</li>
<li><code>FRAG_YES_NOTLAST</code> or <code>FRAG_YES_LAST:</code> the packet is part of a fragmented packet. This function copies the packet into an internal reassembly buffer. If the incoming part completes the packet being reassembled, the <em>buf</em> argument is modified to point to the fully reassembled packet. If, on the other hand, reassembly is not yet complete, then the the <em>buf</em> buffer is set to empty.</li>
<li>Any other value: error.</li>
</ul>
<p>If an error occurs during processing, an error message is logged and the length of <em>buf</em> is set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- The <code><a class="el" href="structfragment__master.html" title="Fragmentation and reassembly state for one VPN tunnel instance.">fragment_master</a></code> structure for this VPN tunnel. </td></tr>
    <tr><td class="paramname">buf</td><td>- A pointer to the buffer structure containing the incoming packet. This pointer will have been modified on return either to point to a completely reassembled packet, or to have length set to zero if reassembly is not yet complete. </td></tr>
    <tr><td class="paramname">frame</td><td>- The packet geometry parameters for this VPN tunnel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void.<br  />
 On return, the <em>buf</em> argument will point to a buffer. The buffer will have nonzero length if the incoming packet passed to this function was whole and unfragmented, or if it was the final part of a fragmented packet thereby completing reassembly. On the other hand, the buffer will have a length of zero if the incoming packet was part of a fragmented packet and reassembly is not yet complete. If an error occurs during processing, the buffer length is also set to zero. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fragment_8c_source.html#l00141">141</a> of file <a class="el" href="fragment_8c_source.html">fragment.c</a>.</p>

<p class="reference">References <a class="el" href="openvpn_2error_8h_source.html#l00218">ASSERT</a>, <a class="el" href="fragment_8h_source.html#l00086">fragment::buf</a>, <a class="el" href="buffer_8h_source.html#l00735">buf_copy_range()</a>, <a class="el" href="buffer_8h_source.html#l00196">buf_init</a>, <a class="el" href="buffer_8h_source.html#l00784">buf_read()</a>, <a class="el" href="errlevel_8h_source.html#l00122">D_FRAG_DEBUG</a>, <a class="el" href="errlevel_8h_source.html#l00069">D_FRAG_ERRORS</a>, <a class="el" href="fragment_8h_source.html#l00066">fragment::defined</a>, <a class="el" href="openvpn_2error_8h_source.html#l00171">dmsg</a>, <a class="el" href="http-client_8py_source.html#l00006">http-client::f</a>, <a class="el" href="fragment_8c_source.html#l00040">FRAG_ERR</a>, <a class="el" href="fragment_8h_source.html#l00225">FRAG_ID_MASK</a>, <a class="el" href="fragment_8h_source.html#l00227">FRAG_ID_SHIFT</a>, <a class="el" href="fragment_8h_source.html#l00071">FRAG_MAP_MASK</a>, <a class="el" href="fragment_8h_source.html#l00221">FRAG_SEQ_ID_MASK</a>, <a class="el" href="fragment_8h_source.html#l00223">FRAG_SEQ_ID_SHIFT</a>, <a class="el" href="fragment_8h_source.html#l00239">FRAG_SIZE_MASK</a>, <a class="el" href="fragment_8h_source.html#l00244">FRAG_SIZE_ROUND_MASK</a>, <a class="el" href="fragment_8h_source.html#l00243">FRAG_SIZE_ROUND_SHIFT</a>, <a class="el" href="fragment_8h_source.html#l00241">FRAG_SIZE_SHIFT</a>, <a class="el" href="fragment_8h_source.html#l00216">FRAG_TEST</a>, <a class="el" href="fragment_8h_source.html#l00204">FRAG_TYPE_MASK</a>, <a class="el" href="fragment_8h_source.html#l00206">FRAG_TYPE_SHIFT</a>, <a class="el" href="fragment_8h_source.html#l00208">FRAG_WHOLE</a>, <a class="el" href="fragment_8h_source.html#l00213">FRAG_YES_LAST</a>, <a class="el" href="fragment_8h_source.html#l00210">FRAG_YES_NOTLAST</a>, <a class="el" href="common_8h_source.html#l00060">fragment_header_format</a>, <a class="el" href="fragment_8c_source.html#l00067">fragment_list_get_buf()</a>, <a class="el" href="mtu_8h_source.html#l00188">FRAME_HEADROOM_ADJ</a>, <a class="el" href="mtu_8h_source.html#l00130">FRAME_HEADROOM_MARKER_FRAGMENT</a>, <a class="el" href="buffer_8h_source.html#l00066">buffer::len</a>, <a class="el" href="fragment_8h_source.html#l00074">fragment::map</a>, <a class="el" href="fragment_8h_source.html#l00069">fragment::max_frag_size</a>, <a class="el" href="openvpn_2error_8h_source.html#l00170">msg</a>, <a class="el" href="otime_8c_source.html#l00036">now</a>, <a class="el" href="fragment_8h_source.html#l00199">ntoh_fragment_header_type</a>, and <a class="el" href="fragment_8h_source.html#l00084">fragment::timestamp</a>.</p>

<p class="reference">Referenced by <a class="el" href="forward_8c_source.html#l01054">process_incoming_link_part2()</a>.</p>

</div>
</div>
<a id="ga0be982cb04c4e5c3344d8f91323f4d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0be982cb04c4e5c3344d8f91323f4d8c">&#9670;&nbsp;</a></span>fragment_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structfragment__master.html">fragment_master</a>* fragment_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structframe.html">frame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a <code><a class="el" href="structfragment__master.html" title="Fragmentation and reassembly state for one VPN tunnel instance.">fragment_master</a></code> structure. </p>
<p>This function also modifies the <em>frame</em> packet geometry parameters to include space for the fragmentation header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>- The packet geometry parameters for this VPN tunnel, modified by this function to include the fragmentation header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new <code><a class="el" href="structfragment__master.html" title="Fragmentation and reassembly state for one VPN tunnel instance.">fragment_master</a></code> structure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fragment_8c_source.html#l00091">91</a> of file <a class="el" href="fragment_8c_source.html">fragment.c</a>.</p>

<p class="reference">References <a class="el" href="buffer_8h_source.html#l01059">ALLOC_OBJ_CLEAR</a>, <a class="el" href="interval_8h_source.html#l00166">event_timeout_init()</a>, <a class="el" href="fragment_8h_source.html#l00057">FRAG_WAKEUP_INTERVAL</a>, <a class="el" href="mtu_8h_source.html#l00274">frame_add_to_extra_frame()</a>, <a class="el" href="crypto_8c_source.html#l01771">get_random()</a>, <a class="el" href="fragment_8h_source.html#l00142">N_SEQ_ID</a>, <a class="el" href="otime_8c_source.html#l00036">now</a>, <a class="el" href="fragment_8h_source.html#l00146">fragment_master::outgoing_seq_id</a>, and <a class="el" href="fragment_8h_source.html#l00137">fragment_master::wakeup</a>.</p>

<p class="reference">Referenced by <a class="el" href="init_8c_source.html#l04151">init_instance()</a>.</p>

</div>
</div>
<a id="ga8d431d13746c625db07ffbef8fdb4b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d431d13746c625db07ffbef8fdb4b63">&#9670;&nbsp;</a></span>fragment_outgoing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fragment_outgoing </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfragment__master.html">fragment_master</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structframe.html">frame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process an outgoing packet, which may or may not need to be fragmented. </p>
<p>This function inspects the outgoing packet, determines whether it needs to be fragmented, and processes it accordingly.</p>
<p>Depending on the size of the outgoing packet and the packet geometry parameters for the VPN tunnel, the packet will or will not be fragmented. </p><ul>
<li>Packet size is less than or equal to the maximum packet size for this VPN tunnel: fragmentation is not necessary. The <em>buf</em> argument points to a buffer containing the unmodified outgoing packet with a fragmentation header indicating the packet is whole (FRAG_WHOLE) prepended. </li>
<li>Packet size is greater than the maximum packet size for this VPN tunnel: fragmentation is necessary. The original outgoing packet is copied into an internal buffer for fragmentation. The <em>buf</em> argument is modified to point to the first part of the fragmented packet. The remaining parts remain stored in the internal buffer, and can be retrieved using the <code><a class="el" href="group__fragmentation.html#gafee718405669b72a316b31225da38485" title="Check whether outgoing fragments are ready to be send, and if so make one available.">fragment_ready_to_send()</a></code> function.</li>
</ul>
<p>If an error occurs during processing, an error message is logged and the length of <em>buf</em> is set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- The <code><a class="el" href="structfragment__master.html" title="Fragmentation and reassembly state for one VPN tunnel instance.">fragment_master</a></code> structure for this VPN tunnel. </td></tr>
    <tr><td class="paramname">buf</td><td>- A pointer to the buffer structure containing the outgoing packet. This pointer will be modified to point to a whole unfragmented packet or to the first part of a fragmented packet on return. </td></tr>
    <tr><td class="paramname">frame</td><td>- The packet geometry parameters for this VPN tunnel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Void.<br  />
 On return, the <em>buf</em> argument will point to a buffer. This buffer contains either the whole original outgoing packet if fragmentation was not necessary, or the first part of the fragmented outgoing packet if fragmentation was necessary. In both cases a fragmentation header will have been prepended to inform the remote peer how to handle the packet. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fragment_8c_source.html#l00326">326</a> of file <a class="el" href="fragment_8c_source.html">fragment.c</a>.</p>

<p class="reference">References <a class="el" href="openvpn_2error_8h_source.html#l00218">ASSERT</a>, <a class="el" href="fragment_8h_source.html#l00086">fragment::buf</a>, <a class="el" href="buffer_8h_source.html#l00718">buf_copy()</a>, <a class="el" href="buffer_8h_source.html#l00196">buf_init</a>, <a class="el" href="errlevel_8h_source.html#l00069">D_FRAG_ERRORS</a>, <a class="el" href="http-client_8py_source.html#l00006">http-client::f</a>, <a class="el" href="fragment_8c_source.html#l00040">FRAG_ERR</a>, <a class="el" href="fragment_8h_source.html#l00208">FRAG_WHOLE</a>, <a class="el" href="fragment_8c_source.html#l00266">fragment_prepend_flags()</a>, <a class="el" href="fragment_8c_source.html#l00381">fragment_ready_to_send()</a>, <a class="el" href="mtu_8h_source.html#l00187">FRAME_HEADROOM</a>, <a class="el" href="buffer_8h_source.html#l00066">buffer::len</a>, <a class="el" href="fragment_8h_source.html#l00073">MAX_FRAGS</a>, <a class="el" href="integer_8h_source.html#l00116">modulo_add()</a>, <a class="el" href="openvpn_2error_8h_source.html#l00170">msg</a>, <a class="el" href="fragment_8h_source.html#l00142">N_SEQ_ID</a>, <a class="el" href="fragment_8c_source.html#l00307">optimal_fragment_size()</a>, and <a class="el" href="mtu_8h_source.html#l00166">PAYLOAD_SIZE_DYNAMIC</a>.</p>

<p class="reference">Referenced by <a class="el" href="forward_8c_source.html#l00569">encrypt_sign()</a>.</p>

</div>
</div>
<a id="ga7e459710a8c1f5d5f8446d92106119b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e459710a8c1f5d5f8446d92106119b0">&#9670;&nbsp;</a></span>fragment_outgoing_defined()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool fragment_outgoing_defined </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfragment__master.html">fragment_master</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a <code><a class="el" href="structfragment__master.html" title="Fragmentation and reassembly state for one VPN tunnel instance.">fragment_master</a></code> structure contains fragments ready to be sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- The <code><a class="el" href="structfragment__master.html" title="Fragmentation and reassembly state for one VPN tunnel instance.">fragment_master</a></code> structure for this VPN tunnel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if there are one or more fragments ready to be sent. </li>
<li>False, otherwise. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="fragment_8h_source.html#l00440">440</a> of file <a class="el" href="fragment_8h_source.html">fragment.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="forward_8c_source.html#l00520">check_fragment()</a>, and <a class="el" href="fragment_8c_source.html#l00381">fragment_ready_to_send()</a>.</p>

</div>
</div>
<a id="gafee718405669b72a316b31225da38485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafee718405669b72a316b31225da38485">&#9670;&nbsp;</a></span>fragment_ready_to_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fragment_ready_to_send </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfragment__master.html">fragment_master</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer.html">buffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structframe.html">frame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether outgoing fragments are ready to be send, and if so make one available. </p>
<p>This function checks whether the internal buffer for fragmenting outgoing packets contains any unsent parts. If it does not, meaning there is nothing waiting to be sent, it returns false. Otherwise there are parts ready to be sent, and it returns true. In that case it also modifies the <em>buf</em> argument to point to a buffer containing the next part to be sent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- The <em><a class="el" href="structfragment__master.html" title="Fragmentation and reassembly state for one VPN tunnel instance.">fragment_master</a></em> structure for this VPN tunnel. </td></tr>
    <tr><td class="paramname">buf</td><td>- A pointer to a buffer structure which on return, if there are parts waiting to be sent, will point to the next part to be sent. </td></tr>
    <tr><td class="paramname">frame</td><td>- The packet geometry parameters for this VPN tunnel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>True, if an outgoing packet has been fragmented and not all parts have been sent yet. In this case this function will modify the <em>buf</em> argument to point to a buffer containing the next part to be sent. </li>
<li>False, if there are no outgoing fragmented parts waiting to be sent. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="fragment_8c_source.html#l00381">381</a> of file <a class="el" href="fragment_8c_source.html">fragment.c</a>.</p>

<p class="reference">References <a class="el" href="openvpn_2error_8h_source.html#l00218">ASSERT</a>, <a class="el" href="fragment_8h_source.html#l00086">fragment::buf</a>, <a class="el" href="buffer_8h_source.html#l00724">buf_copy_n()</a>, <a class="el" href="buffer_8h_source.html#l00196">buf_init</a>, <a class="el" href="http-client_8py_source.html#l00006">http-client::f</a>, <a class="el" href="fragment_8h_source.html#l00213">FRAG_YES_LAST</a>, <a class="el" href="fragment_8h_source.html#l00210">FRAG_YES_NOTLAST</a>, <a class="el" href="fragment_8h_source.html#l00440">fragment_outgoing_defined()</a>, <a class="el" href="fragment_8c_source.html#l00266">fragment_prepend_flags()</a>, and <a class="el" href="mtu_8h_source.html#l00187">FRAME_HEADROOM</a>.</p>

<p class="reference">Referenced by <a class="el" href="forward_8c_source.html#l00520">check_fragment()</a>, and <a class="el" href="fragment_8c_source.html#l00326">fragment_outgoing()</a>.</p>

</div>
</div>
<a id="gacf00a549c0d55a864584b128cd1d1927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf00a549c0d55a864584b128cd1d1927">&#9670;&nbsp;</a></span>fragment_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fragment_wakeup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfragment__master.html">fragment_master</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structframe.html">frame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="fragment_8c_source.html#l00434">434</a> of file <a class="el" href="fragment_8c_source.html">fragment.c</a>.</p>

<p class="reference">References <a class="el" href="http-client_8py_source.html#l00006">http-client::f</a>, and <a class="el" href="fragment_8c_source.html#l00418">fragment_ttl_reap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="fragment_8h_source.html#l00467">fragment_housekeeping()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
