<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mbed TLS v3.5.1: Interruptible sign/verify hash</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mbed TLS v3.5.1
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Interruptible sign/verify hash</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga6948d4653175b1b530a265540066a7e7"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structpsa__sign__hash__interruptible__operation__s.html">psa_sign_hash_interruptible_operation_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interruptible__hash.html#ga6948d4653175b1b530a265540066a7e7">psa_sign_hash_interruptible_operation_t</a></td></tr>
<tr class="separator:ga6948d4653175b1b530a265540066a7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga537054cf4909ad1426331ae4ce7148bb"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structpsa__verify__hash__interruptible__operation__s.html">psa_verify_hash_interruptible_operation_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interruptible__hash.html#ga537054cf4909ad1426331ae4ce7148bb">psa_verify_hash_interruptible_operation_t</a></td></tr>
<tr class="separator:ga537054cf4909ad1426331ae4ce7148bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6d86790b31657c13705214f373af869e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interruptible__hash.html#ga6d86790b31657c13705214f373af869e">psa_interruptible_set_max_ops</a> (uint32_t max_ops)</td></tr>
<tr class="memdesc:ga6d86790b31657c13705214f373af869e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of ops allowed to be executed by an interruptible function in a single call.  <a href="group__interruptible__hash.html#ga6d86790b31657c13705214f373af869e">More...</a><br /></td></tr>
<tr class="separator:ga6d86790b31657c13705214f373af869e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73e66a6d93f2690b626fcea20ada62b2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interruptible__hash.html#ga73e66a6d93f2690b626fcea20ada62b2">psa_interruptible_get_max_ops</a> (void)</td></tr>
<tr class="memdesc:ga73e66a6d93f2690b626fcea20ada62b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of ops allowed to be executed by an interruptible function in a single call. This will return the last value set by <code><a class="el" href="group__interruptible__hash.html#ga6d86790b31657c13705214f373af869e" title="Set the maximum number of ops allowed to be executed by an interruptible function in a single call.">psa_interruptible_set_max_ops()</a></code> or <a class="el" href="group__interruptible.html#gad19c1da7f6b7d59d5873d5b68eb943d4">PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED</a> if that function has never been called.  <a href="group__interruptible__hash.html#ga73e66a6d93f2690b626fcea20ada62b2">More...</a><br /></td></tr>
<tr class="separator:ga73e66a6d93f2690b626fcea20ada62b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2740b39986a7bd6b8dd61b9e36770ef2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interruptible__hash.html#ga2740b39986a7bd6b8dd61b9e36770ef2">psa_sign_hash_get_num_ops</a> (const <a class="el" href="group__interruptible__hash.html#ga6948d4653175b1b530a265540066a7e7">psa_sign_hash_interruptible_operation_t</a> *operation)</td></tr>
<tr class="memdesc:ga2740b39986a7bd6b8dd61b9e36770ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ops that a hash signing operation has taken so far. If the operation has completed, then this will represent the number of ops required for the entire operation. After initialization or calling <code>psa_sign_hash_interruptible_abort()</code> on the operation, a value of 0 will be returned.  <a href="group__interruptible__hash.html#ga2740b39986a7bd6b8dd61b9e36770ef2">More...</a><br /></td></tr>
<tr class="separator:ga2740b39986a7bd6b8dd61b9e36770ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0abdbf79939c61a9726342f3a1ab59d7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interruptible__hash.html#ga0abdbf79939c61a9726342f3a1ab59d7">psa_verify_hash_get_num_ops</a> (const <a class="el" href="group__interruptible__hash.html#ga537054cf4909ad1426331ae4ce7148bb">psa_verify_hash_interruptible_operation_t</a> *operation)</td></tr>
<tr class="memdesc:ga0abdbf79939c61a9726342f3a1ab59d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ops that a hash verification operation has taken so far. If the operation has completed, then this will represent the number of ops required for the entire operation. After initialization or calling <code>psa_verify_hash_interruptible_abort()</code> on the operation, a value of 0 will be returned.  <a href="group__interruptible__hash.html#ga0abdbf79939c61a9726342f3a1ab59d7">More...</a><br /></td></tr>
<tr class="separator:ga0abdbf79939c61a9726342f3a1ab59d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga441988da830205182b3e791352537fac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interruptible__hash.html#ga441988da830205182b3e791352537fac">psa_sign_hash_start</a> (<a class="el" href="group__interruptible__hash.html#ga6948d4653175b1b530a265540066a7e7">psa_sign_hash_interruptible_operation_t</a> *operation, <a class="el" href="group__key__lifetimes.html#ga9a5375bd0cb9694f3a2694adc0a6ae13">mbedtls_svc_key_id_t</a> key, <a class="el" href="group__crypto__types.html#gac2e4d47f1300d73c2f829a6d99252d69">psa_algorithm_t</a> alg, const uint8_t *hash, size_t hash_length)</td></tr>
<tr class="memdesc:ga441988da830205182b3e791352537fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start signing a hash or short message with a private key, in an interruptible manner.  <a href="group__interruptible__hash.html#ga441988da830205182b3e791352537fac">More...</a><br /></td></tr>
<tr class="separator:ga441988da830205182b3e791352537fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79849aaa7004a85d2ffbc4b658a333dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interruptible__hash.html#ga79849aaa7004a85d2ffbc4b658a333dd">psa_sign_hash_complete</a> (<a class="el" href="group__interruptible__hash.html#ga6948d4653175b1b530a265540066a7e7">psa_sign_hash_interruptible_operation_t</a> *operation, uint8_t *signature, size_t signature_size, size_t *signature_length)</td></tr>
<tr class="memdesc:ga79849aaa7004a85d2ffbc4b658a333dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Continue and eventually complete the action of signing a hash or short message with a private key, in an interruptible manner.  <a href="group__interruptible__hash.html#ga79849aaa7004a85d2ffbc4b658a333dd">More...</a><br /></td></tr>
<tr class="separator:ga79849aaa7004a85d2ffbc4b658a333dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae893a4813aa8e03bd201fe4f1bbbb403"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interruptible__hash.html#gae893a4813aa8e03bd201fe4f1bbbb403">psa_sign_hash_abort</a> (<a class="el" href="group__interruptible__hash.html#ga6948d4653175b1b530a265540066a7e7">psa_sign_hash_interruptible_operation_t</a> *operation)</td></tr>
<tr class="memdesc:gae893a4813aa8e03bd201fe4f1bbbb403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort a sign hash operation.  <a href="group__interruptible__hash.html#gae893a4813aa8e03bd201fe4f1bbbb403">More...</a><br /></td></tr>
<tr class="separator:gae893a4813aa8e03bd201fe4f1bbbb403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga912eb51fb94056858f451f276ee289cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interruptible__hash.html#ga912eb51fb94056858f451f276ee289cb">psa_verify_hash_start</a> (<a class="el" href="group__interruptible__hash.html#ga537054cf4909ad1426331ae4ce7148bb">psa_verify_hash_interruptible_operation_t</a> *operation, <a class="el" href="group__key__lifetimes.html#ga9a5375bd0cb9694f3a2694adc0a6ae13">mbedtls_svc_key_id_t</a> key, <a class="el" href="group__crypto__types.html#gac2e4d47f1300d73c2f829a6d99252d69">psa_algorithm_t</a> alg, const uint8_t *hash, size_t hash_length, const uint8_t *signature, size_t signature_length)</td></tr>
<tr class="memdesc:ga912eb51fb94056858f451f276ee289cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start reading and verifying a hash or short message, in an interruptible manner.  <a href="group__interruptible__hash.html#ga912eb51fb94056858f451f276ee289cb">More...</a><br /></td></tr>
<tr class="separator:ga912eb51fb94056858f451f276ee289cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67fe82352bc2f8c0343e231a70a5bc7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interruptible__hash.html#ga67fe82352bc2f8c0343e231a70a5bc7d">psa_verify_hash_complete</a> (<a class="el" href="group__interruptible__hash.html#ga537054cf4909ad1426331ae4ce7148bb">psa_verify_hash_interruptible_operation_t</a> *operation)</td></tr>
<tr class="memdesc:ga67fe82352bc2f8c0343e231a70a5bc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Continue and eventually complete the action of reading and verifying a hash or short message signed with a private key, in an interruptible manner.  <a href="group__interruptible__hash.html#ga67fe82352bc2f8c0343e231a70a5bc7d">More...</a><br /></td></tr>
<tr class="separator:ga67fe82352bc2f8c0343e231a70a5bc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18dc9c0cc27d590c5e3b186094d90f88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interruptible__hash.html#ga18dc9c0cc27d590c5e3b186094d90f88">psa_verify_hash_abort</a> (<a class="el" href="group__interruptible__hash.html#ga537054cf4909ad1426331ae4ce7148bb">psa_verify_hash_interruptible_operation_t</a> *operation)</td></tr>
<tr class="memdesc:ga18dc9c0cc27d590c5e3b186094d90f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort a verify hash operation.  <a href="group__interruptible__hash.html#ga18dc9c0cc27d590c5e3b186094d90f88">More...</a><br /></td></tr>
<tr class="separator:ga18dc9c0cc27d590c5e3b186094d90f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga6948d4653175b1b530a265540066a7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6948d4653175b1b530a265540066a7e7">&#9670;&nbsp;</a></span>psa_sign_hash_interruptible_operation_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structpsa__sign__hash__interruptible__operation__s.html">psa_sign_hash_interruptible_operation_s</a> <a class="el" href="group__interruptible__hash.html#ga6948d4653175b1b530a265540066a7e7">psa_sign_hash_interruptible_operation_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of the state data structure for interruptible hash signing operations.</p>
<p>Before calling any function on a sign hash operation object, the application must initialize it by any of the following means:</p><ul>
<li>Set the structure to all-bits-zero, for example: <div class="fragment"><div class="line"><a class="code" href="structpsa__sign__hash__interruptible__operation__s.html">psa_sign_hash_interruptible_operation_t</a> operation;</div>
<div class="line">memset(&amp;operation, 0, <span class="keyword">sizeof</span>(operation));</div>
</div><!-- fragment --></li>
<li>Initialize the structure to logical zero values, for example: <div class="fragment"><div class="line"><a class="code" href="structpsa__sign__hash__interruptible__operation__s.html">psa_sign_hash_interruptible_operation_t</a> operation = {0};</div>
</div><!-- fragment --></li>
<li>Initialize the structure to the initializer <a class="el" href="crypto__struct_8h.html#ae8d7c502f24f810c3abad377daa8b051">PSA_SIGN_HASH_INTERRUPTIBLE_OPERATION_INIT</a>, for example: <div class="fragment"><div class="line"><a class="code" href="structpsa__sign__hash__interruptible__operation__s.html">psa_sign_hash_interruptible_operation_t</a> operation =</div>
<div class="line"><a class="code" href="crypto__struct_8h.html#ae8d7c502f24f810c3abad377daa8b051">PSA_SIGN_HASH_INTERRUPTIBLE_OPERATION_INIT</a>;</div>
</div><!-- fragment --></li>
<li>Assign the result of the function <a class="el" href="crypto__struct_8h.html#a12166ea6ade6825a053b698ed510ef33">psa_sign_hash_interruptible_operation_init()</a> to the structure, for example: <div class="fragment"><div class="line"><a class="code" href="structpsa__sign__hash__interruptible__operation__s.html">psa_sign_hash_interruptible_operation_t</a> operation;</div>
<div class="line">operation = <a class="code" href="crypto__struct_8h.html#a12166ea6ade6825a053b698ed510ef33">psa_sign_hash_interruptible_operation_init</a>();</div>
</div><!-- fragment --></li>
</ul>
<p>This is an implementation-defined <code>struct</code>. Applications should not make any assumptions about the content of this structure. Implementation details can change in future versions without notice. </p>

<p class="definition">Definition at line <a class="el" href="crypto_8h_source.html#l04075">4075</a> of file <a class="el" href="crypto_8h_source.html">crypto.h</a>.</p>

</div>
</div>
<a id="ga537054cf4909ad1426331ae4ce7148bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga537054cf4909ad1426331ae4ce7148bb">&#9670;&nbsp;</a></span>psa_verify_hash_interruptible_operation_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structpsa__verify__hash__interruptible__operation__s.html">psa_verify_hash_interruptible_operation_s</a> <a class="el" href="group__interruptible__hash.html#ga537054cf4909ad1426331ae4ce7148bb">psa_verify_hash_interruptible_operation_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of the state data structure for interruptible hash verification operations.</p>
<p>Before calling any function on a sign hash operation object, the application must initialize it by any of the following means:</p><ul>
<li>Set the structure to all-bits-zero, for example: <div class="fragment"><div class="line"><a class="code" href="structpsa__verify__hash__interruptible__operation__s.html">psa_verify_hash_interruptible_operation_t</a> operation;</div>
<div class="line">memset(&amp;operation, 0, <span class="keyword">sizeof</span>(operation));</div>
</div><!-- fragment --></li>
<li>Initialize the structure to logical zero values, for example: <div class="fragment"><div class="line"><a class="code" href="structpsa__verify__hash__interruptible__operation__s.html">psa_verify_hash_interruptible_operation_t</a> operation = {0};</div>
</div><!-- fragment --></li>
<li>Initialize the structure to the initializer <a class="el" href="crypto__struct_8h.html#aed5b04a316ca690bd97f5ea0d2b905b9">PSA_VERIFY_HASH_INTERRUPTIBLE_OPERATION_INIT</a>, for example: <div class="fragment"><div class="line"><a class="code" href="structpsa__verify__hash__interruptible__operation__s.html">psa_verify_hash_interruptible_operation_t</a> operation =</div>
<div class="line"><a class="code" href="crypto__struct_8h.html#aed5b04a316ca690bd97f5ea0d2b905b9">PSA_VERIFY_HASH_INTERRUPTIBLE_OPERATION_INIT</a>;</div>
</div><!-- fragment --></li>
<li>Assign the result of the function <a class="el" href="crypto__struct_8h.html#a570efe3897a9133ffa0373b9984d076c">psa_verify_hash_interruptible_operation_init()</a> to the structure, for example: <div class="fragment"><div class="line"><a class="code" href="structpsa__verify__hash__interruptible__operation__s.html">psa_verify_hash_interruptible_operation_t</a> operation;</div>
<div class="line">operation = <a class="code" href="crypto__struct_8h.html#a570efe3897a9133ffa0373b9984d076c">psa_verify_hash_interruptible_operation_init</a>();</div>
</div><!-- fragment --></li>
</ul>
<p>This is an implementation-defined <code>struct</code>. Applications should not make any assumptions about the content of this structure. Implementation details can change in future versions without notice. </p>

<p class="definition">Definition at line <a class="el" href="crypto_8h_source.html#l04108">4108</a> of file <a class="el" href="crypto_8h_source.html">crypto.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga73e66a6d93f2690b626fcea20ada62b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73e66a6d93f2690b626fcea20ada62b2">&#9670;&nbsp;</a></span>psa_interruptible_get_max_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t psa_interruptible_get_max_ops </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum number of ops allowed to be executed by an interruptible function in a single call. This will return the last value set by <code><a class="el" href="group__interruptible__hash.html#ga6d86790b31657c13705214f373af869e" title="Set the maximum number of ops allowed to be executed by an interruptible function in a single call.">psa_interruptible_set_max_ops()</a></code> or <a class="el" href="group__interruptible.html#gad19c1da7f6b7d59d5873d5b68eb943d4">PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED</a> if that function has never been called. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is a beta API, and thus subject to change at any point. It is not bound by the usual interface stability promises.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of ops allowed to be executed by an interruptible function in a single call. </dd></dl>

</div>
</div>
<a id="ga6d86790b31657c13705214f373af869e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d86790b31657c13705214f373af869e">&#9670;&nbsp;</a></span>psa_interruptible_set_max_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void psa_interruptible_set_max_ops </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum number of ops allowed to be executed by an interruptible function in a single call. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is a beta API, and thus subject to change at any point. It is not bound by the usual interface stability promises.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The time taken to execute a single op is implementation specific and depends on software, hardware, the algorithm, key type and curve chosen. Even within a single operation, successive ops can take differing amounts of time. The only guarantee is that lower values for <code>max_ops</code> means functions will block for a lesser maximum amount of time. The functions <code>psa_sign_interruptible_get_num_ops()</code> and <code>psa_verify_interruptible_get_num_ops()</code> are provided to help with tuning this value.</dd>
<dd>
This value defaults to <a class="el" href="group__interruptible.html#gad19c1da7f6b7d59d5873d5b68eb943d4">PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED</a>, which means the whole operation will be done in one go, regardless of the number of ops required.</dd>
<dd>
If more ops are needed to complete a computation, <a class="el" href="group__error.html#gac0be2a39bf95ab559b75c7ff616450f0">PSA_OPERATION_INCOMPLETE</a> will be returned by the function performing the computation. It is then the caller's responsibility to either call again with the same operation context until it returns 0 or an error code; or to call the relevant abort function if the answer is no longer required.</dd>
<dd>
The interpretation of <code>max_ops</code> is also implementation defined. On a hard real time system, this can indicate a hard deadline, as a real-time system needs a guarantee of not spending more than X time, however care must be taken in such an implementation to avoid the situation whereby calls just return, not being able to do any actual work within the allotted time. On a non-real-time system, the implementation can be more relaxed, but again whether this number should be interpreted as as hard or soft limit or even whether a less than or equals as regards to ops executed in a single call is implementation defined.</dd>
<dd>
For keys in local storage when no accelerator driver applies, please see also the documentation for <code><a class="el" href="ecp_8h.html#a4116275f34714de2218e8969611b6f42" title="Set the maximum number of basic operations done in a row.">mbedtls_ecp_set_max_ops()</a></code>, which is the internal implementation in these cases.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>With implementations that interpret this number as a hard limit, setting this number too small may result in an infinite loop, whereby each call results in immediate return with no ops done (as there is not enough time to execute any), and thus no result will ever be achieved.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This only applies to functions whose documentation mentions they may return <a class="el" href="group__error.html#gac0be2a39bf95ab559b75c7ff616450f0">PSA_OPERATION_INCOMPLETE</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_ops</td><td>The maximum number of ops to be executed in a single call. This can be a number from 0 to <a class="el" href="group__interruptible.html#gad19c1da7f6b7d59d5873d5b68eb943d4">PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED</a>, where 0 is the least amount of work done per call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae893a4813aa8e03bd201fe4f1bbbb403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae893a4813aa8e03bd201fe4f1bbbb403">&#9670;&nbsp;</a></span>psa_sign_hash_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a> psa_sign_hash_abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__interruptible__hash.html#ga6948d4653175b1b530a265540066a7e7">psa_sign_hash_interruptible_operation_t</a> *&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort a sign hash operation. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is a beta API, and thus subject to change at any point. It is not bound by the usual interface stability promises.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is the only function that clears the number of ops completed as part of the operation. Please ensure you copy this value via <code><a class="el" href="group__interruptible__hash.html#ga2740b39986a7bd6b8dd61b9e36770ef2" title="Get the number of ops that a hash signing operation has taken so far. If the operation has completed,...">psa_sign_hash_get_num_ops()</a></code> if required before calling.</dd>
<dd>
Aborting an operation frees all associated resources except for the <code>operation</code> structure itself. Once aborted, the operation object can be reused for another operation by calling <code><a class="el" href="group__interruptible__hash.html#ga441988da830205182b3e791352537fac" title="Start signing a hash or short message with a private key, in an interruptible manner.">psa_sign_hash_start()</a></code> again.</dd>
<dd>
You may call this function any time after the operation object has been initialized. In particular, calling <code><a class="el" href="group__interruptible__hash.html#gae893a4813aa8e03bd201fe4f1bbbb403" title="Abort a sign hash operation.">psa_sign_hash_abort()</a></code> after the operation has already been terminated by a call to <code><a class="el" href="group__interruptible__hash.html#gae893a4813aa8e03bd201fe4f1bbbb403" title="Abort a sign hash operation.">psa_sign_hash_abort()</a></code> or <a class="el" href="group__interruptible__hash.html#ga79849aaa7004a85d2ffbc4b658a333dd" title="Continue and eventually complete the action of signing a hash or short message with a private key,...">psa_sign_hash_complete()</a> is safe.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">operation</td><td>Initialized sign hash operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td>The operation was aborted successfully.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga1dcc6d130633ed5db8942257581b55dd">PSA_ERROR_NOT_SUPPORTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>The library has not been previously initialized by <a class="el" href="group__initialization.html#ga2de150803fc2f7dc6101d5af7e921dd9" title="Library initialization.">psa_crypto_init()</a>. It is implementation-dependent whether a failure to initialize results in this error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga79849aaa7004a85d2ffbc4b658a333dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79849aaa7004a85d2ffbc4b658a333dd">&#9670;&nbsp;</a></span>psa_sign_hash_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a> psa_sign_hash_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__interruptible__hash.html#ga6948d4653175b1b530a265540066a7e7">psa_sign_hash_interruptible_operation_t</a> *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>signature_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>signature_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Continue and eventually complete the action of signing a hash or short message with a private key, in an interruptible manner. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__interruptible__hash.html#ga441988da830205182b3e791352537fac" title="Start signing a hash or short message with a private key, in an interruptible manner.">psa_sign_hash_start()</a></code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is a beta API, and thus subject to change at any point. It is not bound by the usual interface stability promises.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function combined with <code><a class="el" href="group__interruptible__hash.html#ga441988da830205182b3e791352537fac" title="Start signing a hash or short message with a private key, in an interruptible manner.">psa_sign_hash_start()</a></code> is equivalent to <code><a class="el" href="group__asymmetric.html#ga785e746a31a7b2a35ae5175c5ace3c5c" title="Sign a hash or short message with a private key.">psa_sign_hash()</a></code> but this function can return early and resume according to the limit set with <code><a class="el" href="group__interruptible__hash.html#ga6d86790b31657c13705214f373af869e" title="Set the maximum number of ops allowed to be executed by an interruptible function in a single call.">psa_interruptible_set_max_ops()</a></code> to reduce the maximum time spent in a function call.</dd>
<dd>
Users should call this function on the same operation object repeatedly until it either returns 0 or an error. This function will return <a class="el" href="group__error.html#gac0be2a39bf95ab559b75c7ff616450f0">PSA_OPERATION_INCOMPLETE</a> if there is more work to do. Alternatively users can call <code><a class="el" href="group__interruptible__hash.html#gae893a4813aa8e03bd201fe4f1bbbb403" title="Abort a sign hash operation.">psa_sign_hash_abort()</a></code> at any point if they no longer want the result.</dd>
<dd>
When this function returns successfully, the operation becomes inactive. If this function returns an error status, the operation enters an error state and must be aborted by calling <code><a class="el" href="group__interruptible__hash.html#gae893a4813aa8e03bd201fe4f1bbbb403" title="Abort a sign hash operation.">psa_sign_hash_abort()</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">operation</td><td>The <code>psa_sign_hash_interruptible_operation_t</code> to use. This must be initialized first, and have had <code><a class="el" href="group__interruptible__hash.html#ga441988da830205182b3e791352537fac" title="Start signing a hash or short message with a private key, in an interruptible manner.">psa_sign_hash_start()</a></code> called with it first.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signature</td><td>Buffer where the signature is to be written. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">signature_size</td><td>Size of the <code>signature</code> buffer in bytes. This must be appropriate for the selected algorithm and key:<ul>
<li>The required signature size is <a class="el" href="crypto__sizes_8h.html#a31021bbd8bb365fc350532b5fd18a25a">PSA_SIGN_OUTPUT_SIZE</a>(<code>key_type</code>, <code>key_bits</code>, <code>alg</code>) where <code>key_type</code> and <code>key_bits</code> are the type and bit-size respectively of key.</li>
<li><a class="el" href="crypto__sizes_8h.html#a687a317642db9486fda38ea553900a1e">PSA_SIGNATURE_MAX_SIZE</a> evaluates to the maximum signature size of any supported signature algorithm. </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signature_length</td><td>On success, the number of bytes that make up the returned signature value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td>Operation completed successfully</td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gac0be2a39bf95ab559b75c7ff616450f0">PSA_OPERATION_INCOMPLETE</a></td><td>Operation was interrupted due to the setting of <code><a class="el" href="group__interruptible__hash.html#ga6d86790b31657c13705214f373af869e" title="Set the maximum number of ops allowed to be executed by an interruptible function in a single call.">psa_interruptible_set_max_ops()</a></code>. There is still work to be done. Call this function again with the same operation object.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga695025f4ec11249aee7ea3d0f65e01c8">PSA_ERROR_BUFFER_TOO_SMALL</a></td><td>The size of the <code>signature</code> buffer is too small. You can determine a sufficient buffer size by calling <a class="el" href="crypto__sizes_8h.html#a31021bbd8bb365fc350532b5fd18a25a">PSA_SIGN_OUTPUT_SIZE</a>(<code>key_type</code>, <code>key_bits</code>, <code>alg</code>) where <code>key_type</code> and <code>key_bits</code> are the type and bit-size respectively of <code>key</code>.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>An operation was not previously started on this context via <code><a class="el" href="group__interruptible__hash.html#ga441988da830205182b3e791352537fac" title="Start signing a hash or short message with a private key, in an interruptible manner.">psa_sign_hash_start()</a></code>.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga1dcc6d130633ed5db8942257581b55dd">PSA_ERROR_NOT_SUPPORTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga91b2ad8a867517a2651f1b076c5216e5">PSA_ERROR_INSUFFICIENT_MEMORY</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga5cdb6948371d49e916106249020ea3f7">PSA_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga08b10e70fa5ff0b05c631d9f8f6b2c6b">PSA_ERROR_HARDWARE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga116f4d4c6a9d9db3397991a8472d8950">PSA_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadd169a1af2707862b95fb9df91dfc37d">PSA_ERROR_STORAGE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga9febb81a44bdeb4c6c42bf4f697b13bf">PSA_ERROR_DATA_CORRUPT</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gacebfbd25a7c2a727694fb57182a66533">PSA_ERROR_DATA_INVALID</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4deb59fec02297ec5d8b42178323f675">PSA_ERROR_INSUFFICIENT_ENTROPY</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>The library has either not been previously initialized by <a class="el" href="group__initialization.html#ga2de150803fc2f7dc6101d5af7e921dd9" title="Library initialization.">psa_crypto_init()</a> or you did not previously call <a class="el" href="group__interruptible__hash.html#ga441988da830205182b3e791352537fac" title="Start signing a hash or short message with a private key, in an interruptible manner.">psa_sign_hash_start()</a> with this operation object. It is implementation-dependent whether a failure to initialize results in this error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2740b39986a7bd6b8dd61b9e36770ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2740b39986a7bd6b8dd61b9e36770ef2">&#9670;&nbsp;</a></span>psa_sign_hash_get_num_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t psa_sign_hash_get_num_ops </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__interruptible__hash.html#ga6948d4653175b1b530a265540066a7e7">psa_sign_hash_interruptible_operation_t</a> *&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of ops that a hash signing operation has taken so far. If the operation has completed, then this will represent the number of ops required for the entire operation. After initialization or calling <code>psa_sign_hash_interruptible_abort()</code> on the operation, a value of 0 will be returned. </p>
<dl class="section note"><dt>Note</dt><dd>This interface is guaranteed re-entrant and thus may be called from driver code.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is a beta API, and thus subject to change at any point. It is not bound by the usual interface stability promises.</dd></dl>
<p>This is a helper provided to help you tune the value passed to <code><a class="el" href="group__interruptible__hash.html#ga6d86790b31657c13705214f373af869e" title="Set the maximum number of ops allowed to be executed by an interruptible function in a single call.">psa_interruptible_set_max_ops()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>The <code>psa_sign_hash_interruptible_operation_t</code> to use. This must be initialized first.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of ops that the operation has taken so far. </dd></dl>

</div>
</div>
<a id="ga441988da830205182b3e791352537fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga441988da830205182b3e791352537fac">&#9670;&nbsp;</a></span>psa_sign_hash_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a> psa_sign_hash_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__interruptible__hash.html#ga6948d4653175b1b530a265540066a7e7">psa_sign_hash_interruptible_operation_t</a> *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__key__lifetimes.html#ga9a5375bd0cb9694f3a2694adc0a6ae13">mbedtls_svc_key_id_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__crypto__types.html#gac2e4d47f1300d73c2f829a6d99252d69">psa_algorithm_t</a>&#160;</td>
          <td class="paramname"><em>alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hash_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start signing a hash or short message with a private key, in an interruptible manner. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__interruptible__hash.html#ga79849aaa7004a85d2ffbc4b658a333dd" title="Continue and eventually complete the action of signing a hash or short message with a private key,...">psa_sign_hash_complete()</a></code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is a beta API, and thus subject to change at any point. It is not bound by the usual interface stability promises.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function combined with <code><a class="el" href="group__interruptible__hash.html#ga79849aaa7004a85d2ffbc4b658a333dd" title="Continue and eventually complete the action of signing a hash or short message with a private key,...">psa_sign_hash_complete()</a></code> is equivalent to <code><a class="el" href="group__asymmetric.html#ga785e746a31a7b2a35ae5175c5ace3c5c" title="Sign a hash or short message with a private key.">psa_sign_hash()</a></code> but <code><a class="el" href="group__interruptible__hash.html#ga79849aaa7004a85d2ffbc4b658a333dd" title="Continue and eventually complete the action of signing a hash or short message with a private key,...">psa_sign_hash_complete()</a></code> can return early and resume according to the limit set with <code><a class="el" href="group__interruptible__hash.html#ga6d86790b31657c13705214f373af869e" title="Set the maximum number of ops allowed to be executed by an interruptible function in a single call.">psa_interruptible_set_max_ops()</a></code> to reduce the maximum time spent in a function call.</dd>
<dd>
Users should call <code><a class="el" href="group__interruptible__hash.html#ga79849aaa7004a85d2ffbc4b658a333dd" title="Continue and eventually complete the action of signing a hash or short message with a private key,...">psa_sign_hash_complete()</a></code> repeatedly on the same context after a successful call to this function until <code><a class="el" href="group__interruptible__hash.html#ga79849aaa7004a85d2ffbc4b658a333dd" title="Continue and eventually complete the action of signing a hash or short message with a private key,...">psa_sign_hash_complete()</a></code> either returns 0 or an error. <code><a class="el" href="group__interruptible__hash.html#ga79849aaa7004a85d2ffbc4b658a333dd" title="Continue and eventually complete the action of signing a hash or short message with a private key,...">psa_sign_hash_complete()</a></code> will return <a class="el" href="group__error.html#gac0be2a39bf95ab559b75c7ff616450f0">PSA_OPERATION_INCOMPLETE</a> if there is more work to do. Alternatively users can call <code><a class="el" href="group__interruptible__hash.html#gae893a4813aa8e03bd201fe4f1bbbb403" title="Abort a sign hash operation.">psa_sign_hash_abort()</a></code> at any point if they no longer want the result.</dd>
<dd>
If this function returns an error status, the operation enters an error state and must be aborted by calling <code><a class="el" href="group__interruptible__hash.html#gae893a4813aa8e03bd201fe4f1bbbb403" title="Abort a sign hash operation.">psa_sign_hash_abort()</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">operation</td><td>The <code>psa_sign_hash_interruptible_operation_t</code> to use. This must be initialized first.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>Identifier of the key to use for the operation. It must be an asymmetric key pair. The key must allow the usage <a class="el" href="group__policy.html#ga181c73e00d9e95aa3a8366f26c4380b6">PSA_KEY_USAGE_SIGN_HASH</a>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">alg</td><td>A signature algorithm (<code>PSA_ALG_XXX</code> value such that <a class="el" href="group__crypto__types.html#ga7664f69c28b193cc6cb8368481fcda64">PSA_ALG_IS_SIGN_HASH</a>(<code>alg</code>) is true), that is compatible with the type of <code>key</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>The hash or message to sign. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hash_length</td><td>Size of the <code>hash</code> buffer in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td>The operation started successfully - call <code><a class="el" href="group__interruptible__hash.html#ga79849aaa7004a85d2ffbc4b658a333dd" title="Continue and eventually complete the action of signing a hash or short message with a private key,...">psa_sign_hash_complete()</a></code> with the same context to complete the operation</td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadf22718935657c2c3168c228204085f9">PSA_ERROR_INVALID_HANDLE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4d1b8dd8526177a15a210b7afc1accb1">PSA_ERROR_NOT_PERMITTED</a></td><td>The key does not have the <a class="el" href="group__policy.html#ga181c73e00d9e95aa3a8366f26c4380b6">PSA_KEY_USAGE_SIGN_HASH</a> flag, or it does not permit the requested algorithm. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>An operation has previously been started on this context, and is still in progress. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga1dcc6d130633ed5db8942257581b55dd">PSA_ERROR_NOT_SUPPORTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga91b2ad8a867517a2651f1b076c5216e5">PSA_ERROR_INSUFFICIENT_MEMORY</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga5cdb6948371d49e916106249020ea3f7">PSA_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga08b10e70fa5ff0b05c631d9f8f6b2c6b">PSA_ERROR_HARDWARE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga116f4d4c6a9d9db3397991a8472d8950">PSA_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadd169a1af2707862b95fb9df91dfc37d">PSA_ERROR_STORAGE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga9febb81a44bdeb4c6c42bf4f697b13bf">PSA_ERROR_DATA_CORRUPT</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gacebfbd25a7c2a727694fb57182a66533">PSA_ERROR_DATA_INVALID</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4deb59fec02297ec5d8b42178323f675">PSA_ERROR_INSUFFICIENT_ENTROPY</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>The library has not been previously initialized by <a class="el" href="group__initialization.html#ga2de150803fc2f7dc6101d5af7e921dd9" title="Library initialization.">psa_crypto_init()</a>. It is implementation-dependent whether a failure to initialize results in this error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga18dc9c0cc27d590c5e3b186094d90f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18dc9c0cc27d590c5e3b186094d90f88">&#9670;&nbsp;</a></span>psa_verify_hash_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a> psa_verify_hash_abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__interruptible__hash.html#ga537054cf4909ad1426331ae4ce7148bb">psa_verify_hash_interruptible_operation_t</a> *&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort a verify hash operation. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is a beta API, and thus subject to change at any point. It is not bound by the usual interface stability promises.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is the only function that clears the number of ops completed as part of the operation. Please ensure you copy this value via <code><a class="el" href="group__interruptible__hash.html#ga0abdbf79939c61a9726342f3a1ab59d7" title="Get the number of ops that a hash verification operation has taken so far. If the operation has compl...">psa_verify_hash_get_num_ops()</a></code> if required before calling.</dd>
<dd>
Aborting an operation frees all associated resources except for the operation structure itself. Once aborted, the operation object can be reused for another operation by calling <code><a class="el" href="group__interruptible__hash.html#ga912eb51fb94056858f451f276ee289cb" title="Start reading and verifying a hash or short message, in an interruptible manner.">psa_verify_hash_start()</a></code> again.</dd>
<dd>
You may call this function any time after the operation object has been initialized. In particular, calling <code><a class="el" href="group__interruptible__hash.html#ga18dc9c0cc27d590c5e3b186094d90f88" title="Abort a verify hash operation.">psa_verify_hash_abort()</a></code> after the operation has already been terminated by a call to <code><a class="el" href="group__interruptible__hash.html#ga18dc9c0cc27d590c5e3b186094d90f88" title="Abort a verify hash operation.">psa_verify_hash_abort()</a></code> or <a class="el" href="group__interruptible__hash.html#ga67fe82352bc2f8c0343e231a70a5bc7d" title="Continue and eventually complete the action of reading and verifying a hash or short message signed w...">psa_verify_hash_complete()</a> is safe.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">operation</td><td>Initialized verify hash operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td>The operation was aborted successfully.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga1dcc6d130633ed5db8942257581b55dd">PSA_ERROR_NOT_SUPPORTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>The library has not been previously initialized by <a class="el" href="group__initialization.html#ga2de150803fc2f7dc6101d5af7e921dd9" title="Library initialization.">psa_crypto_init()</a>. It is implementation-dependent whether a failure to initialize results in this error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga67fe82352bc2f8c0343e231a70a5bc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67fe82352bc2f8c0343e231a70a5bc7d">&#9670;&nbsp;</a></span>psa_verify_hash_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a> psa_verify_hash_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__interruptible__hash.html#ga537054cf4909ad1426331ae4ce7148bb">psa_verify_hash_interruptible_operation_t</a> *&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Continue and eventually complete the action of reading and verifying a hash or short message signed with a private key, in an interruptible manner. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__interruptible__hash.html#ga912eb51fb94056858f451f276ee289cb" title="Start reading and verifying a hash or short message, in an interruptible manner.">psa_verify_hash_start()</a></code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is a beta API, and thus subject to change at any point. It is not bound by the usual interface stability promises.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function combined with <code><a class="el" href="group__interruptible__hash.html#ga912eb51fb94056858f451f276ee289cb" title="Start reading and verifying a hash or short message, in an interruptible manner.">psa_verify_hash_start()</a></code> is equivalent to <code><a class="el" href="group__asymmetric.html#gae2ffbf01e5266391aff22b101a49f5f5" title="Verify the signature of a hash or short message using a public key.">psa_verify_hash()</a></code> but this function can return early and resume according to the limit set with <code><a class="el" href="group__interruptible__hash.html#ga6d86790b31657c13705214f373af869e" title="Set the maximum number of ops allowed to be executed by an interruptible function in a single call.">psa_interruptible_set_max_ops()</a></code> to reduce the maximum time spent in a function call.</dd>
<dd>
Users should call this function on the same operation object repeatedly until it either returns 0 or an error. This function will return <a class="el" href="group__error.html#gac0be2a39bf95ab559b75c7ff616450f0">PSA_OPERATION_INCOMPLETE</a> if there is more work to do. Alternatively users can call <code><a class="el" href="group__interruptible__hash.html#ga18dc9c0cc27d590c5e3b186094d90f88" title="Abort a verify hash operation.">psa_verify_hash_abort()</a></code> at any point if they no longer want the result.</dd>
<dd>
When this function returns successfully, the operation becomes inactive. If this function returns an error status, the operation enters an error state and must be aborted by calling <code><a class="el" href="group__interruptible__hash.html#ga18dc9c0cc27d590c5e3b186094d90f88" title="Abort a verify hash operation.">psa_verify_hash_abort()</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">operation</td><td>The <code>psa_verify_hash_interruptible_operation_t</code> to use. This must be initialized first, and have had <code><a class="el" href="group__interruptible__hash.html#ga912eb51fb94056858f451f276ee289cb" title="Start reading and verifying a hash or short message, in an interruptible manner.">psa_verify_hash_start()</a></code> called with it first.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td>Operation completed successfully, and the passed signature is valid.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gac0be2a39bf95ab559b75c7ff616450f0">PSA_OPERATION_INCOMPLETE</a></td><td>Operation was interrupted due to the setting of <code><a class="el" href="group__interruptible__hash.html#ga6d86790b31657c13705214f373af869e" title="Set the maximum number of ops allowed to be executed by an interruptible function in a single call.">psa_interruptible_set_max_ops()</a></code>. There is still work to be done. Call this function again with the same operation object.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadf22718935657c2c3168c228204085f9">PSA_ERROR_INVALID_HANDLE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga35927f755d232c4766de600f2c49e9f2">PSA_ERROR_INVALID_SIGNATURE</a></td><td>The calculation was performed successfully, but the passed signature is not a valid signature. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>An operation was not previously started on this context via <code><a class="el" href="group__interruptible__hash.html#ga912eb51fb94056858f451f276ee289cb" title="Start reading and verifying a hash or short message, in an interruptible manner.">psa_verify_hash_start()</a></code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga1dcc6d130633ed5db8942257581b55dd">PSA_ERROR_NOT_SUPPORTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga91b2ad8a867517a2651f1b076c5216e5">PSA_ERROR_INSUFFICIENT_MEMORY</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga5cdb6948371d49e916106249020ea3f7">PSA_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga08b10e70fa5ff0b05c631d9f8f6b2c6b">PSA_ERROR_HARDWARE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga116f4d4c6a9d9db3397991a8472d8950">PSA_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadd169a1af2707862b95fb9df91dfc37d">PSA_ERROR_STORAGE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga9febb81a44bdeb4c6c42bf4f697b13bf">PSA_ERROR_DATA_CORRUPT</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gacebfbd25a7c2a727694fb57182a66533">PSA_ERROR_DATA_INVALID</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4deb59fec02297ec5d8b42178323f675">PSA_ERROR_INSUFFICIENT_ENTROPY</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>The library has either not been previously initialized by <a class="el" href="group__initialization.html#ga2de150803fc2f7dc6101d5af7e921dd9" title="Library initialization.">psa_crypto_init()</a> or you did not previously call <a class="el" href="group__interruptible__hash.html#ga912eb51fb94056858f451f276ee289cb" title="Start reading and verifying a hash or short message, in an interruptible manner.">psa_verify_hash_start()</a> on this object. It is implementation-dependent whether a failure to initialize results in this error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0abdbf79939c61a9726342f3a1ab59d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0abdbf79939c61a9726342f3a1ab59d7">&#9670;&nbsp;</a></span>psa_verify_hash_get_num_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t psa_verify_hash_get_num_ops </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__interruptible__hash.html#ga537054cf4909ad1426331ae4ce7148bb">psa_verify_hash_interruptible_operation_t</a> *&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of ops that a hash verification operation has taken so far. If the operation has completed, then this will represent the number of ops required for the entire operation. After initialization or calling <code>psa_verify_hash_interruptible_abort()</code> on the operation, a value of 0 will be returned. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is a beta API, and thus subject to change at any point. It is not bound by the usual interface stability promises.</dd></dl>
<p>This is a helper provided to help you tune the value passed to <code><a class="el" href="group__interruptible__hash.html#ga6d86790b31657c13705214f373af869e" title="Set the maximum number of ops allowed to be executed by an interruptible function in a single call.">psa_interruptible_set_max_ops()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>The <code>psa_verify_hash_interruptible_operation_t</code> to use. This must be initialized first.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of ops that the operation has taken so far. </dd></dl>

</div>
</div>
<a id="ga912eb51fb94056858f451f276ee289cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga912eb51fb94056858f451f276ee289cb">&#9670;&nbsp;</a></span>psa_verify_hash_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__error.html#ga05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a> psa_verify_hash_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__interruptible__hash.html#ga537054cf4909ad1426331ae4ce7148bb">psa_verify_hash_interruptible_operation_t</a> *&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__key__lifetimes.html#ga9a5375bd0cb9694f3a2694adc0a6ae13">mbedtls_svc_key_id_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__crypto__types.html#gac2e4d47f1300d73c2f829a6d99252d69">psa_algorithm_t</a>&#160;</td>
          <td class="paramname"><em>alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hash_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>signature_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start reading and verifying a hash or short message, in an interruptible manner. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__interruptible__hash.html#ga67fe82352bc2f8c0343e231a70a5bc7d" title="Continue and eventually complete the action of reading and verifying a hash or short message signed w...">psa_verify_hash_complete()</a></code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is a beta API, and thus subject to change at any point. It is not bound by the usual interface stability promises.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function combined with <code><a class="el" href="group__interruptible__hash.html#ga67fe82352bc2f8c0343e231a70a5bc7d" title="Continue and eventually complete the action of reading and verifying a hash or short message signed w...">psa_verify_hash_complete()</a></code> is equivalent to <code><a class="el" href="group__asymmetric.html#gae2ffbf01e5266391aff22b101a49f5f5" title="Verify the signature of a hash or short message using a public key.">psa_verify_hash()</a></code> but <code><a class="el" href="group__interruptible__hash.html#ga67fe82352bc2f8c0343e231a70a5bc7d" title="Continue and eventually complete the action of reading and verifying a hash or short message signed w...">psa_verify_hash_complete()</a></code> can return early and resume according to the limit set with <code><a class="el" href="group__interruptible__hash.html#ga6d86790b31657c13705214f373af869e" title="Set the maximum number of ops allowed to be executed by an interruptible function in a single call.">psa_interruptible_set_max_ops()</a></code> to reduce the maximum time spent in a function.</dd>
<dd>
Users should call <code><a class="el" href="group__interruptible__hash.html#ga67fe82352bc2f8c0343e231a70a5bc7d" title="Continue and eventually complete the action of reading and verifying a hash or short message signed w...">psa_verify_hash_complete()</a></code> repeatedly on the same operation object after a successful call to this function until <code><a class="el" href="group__interruptible__hash.html#ga67fe82352bc2f8c0343e231a70a5bc7d" title="Continue and eventually complete the action of reading and verifying a hash or short message signed w...">psa_verify_hash_complete()</a></code> either returns 0 or an error. <code><a class="el" href="group__interruptible__hash.html#ga67fe82352bc2f8c0343e231a70a5bc7d" title="Continue and eventually complete the action of reading and verifying a hash or short message signed w...">psa_verify_hash_complete()</a></code> will return <a class="el" href="group__error.html#gac0be2a39bf95ab559b75c7ff616450f0">PSA_OPERATION_INCOMPLETE</a> if there is more work to do. Alternatively users can call <code><a class="el" href="group__interruptible__hash.html#ga18dc9c0cc27d590c5e3b186094d90f88" title="Abort a verify hash operation.">psa_verify_hash_abort()</a></code> at any point if they no longer want the result.</dd>
<dd>
If this function returns an error status, the operation enters an error state and must be aborted by calling <code><a class="el" href="group__interruptible__hash.html#ga18dc9c0cc27d590c5e3b186094d90f88" title="Abort a verify hash operation.">psa_verify_hash_abort()</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">operation</td><td>The <code>psa_verify_hash_interruptible_operation_t</code> to use. This must be initialized first.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>Identifier of the key to use for the operation. The key must allow the usage <a class="el" href="group__policy.html#gafadf131ef2182045e3483d03aadaa1bd">PSA_KEY_USAGE_VERIFY_HASH</a>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">alg</td><td>A signature algorithm (<code>PSA_ALG_XXX</code> value such that <a class="el" href="group__crypto__types.html#ga7664f69c28b193cc6cb8368481fcda64">PSA_ALG_IS_SIGN_HASH</a>(<code>alg</code>) is true), that is compatible with the type of <code>key</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash</td><td>The hash whose signature is to be verified. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hash_length</td><td>Size of the <code>hash</code> buffer in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signature</td><td>Buffer containing the signature to verify. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">signature_length</td><td>Size of the <code>signature</code> buffer in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a></td><td>The operation started successfully - please call <code><a class="el" href="group__interruptible__hash.html#ga67fe82352bc2f8c0343e231a70a5bc7d" title="Continue and eventually complete the action of reading and verifying a hash or short message signed w...">psa_verify_hash_complete()</a></code> with the same context to complete the operation.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>Another operation has already been started on this context, and is still in progress.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga4d1b8dd8526177a15a210b7afc1accb1">PSA_ERROR_NOT_PERMITTED</a></td><td>The key does not have the <a class="el" href="group__policy.html#gafadf131ef2182045e3483d03aadaa1bd">PSA_KEY_USAGE_VERIFY_HASH</a> flag, or it does not permit the requested algorithm.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga1dcc6d130633ed5db8942257581b55dd">PSA_ERROR_NOT_SUPPORTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga91b2ad8a867517a2651f1b076c5216e5">PSA_ERROR_INSUFFICIENT_MEMORY</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga5cdb6948371d49e916106249020ea3f7">PSA_ERROR_COMMUNICATION_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga08b10e70fa5ff0b05c631d9f8f6b2c6b">PSA_ERROR_HARDWARE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga116f4d4c6a9d9db3397991a8472d8950">PSA_ERROR_CORRUPTION_DETECTED</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#gadd169a1af2707862b95fb9df91dfc37d">PSA_ERROR_STORAGE_FAILURE</a></td><td></td></tr>
    <tr><td class="paramname">PSA_ERROR_DATA_CORRUPT</td><td></td></tr>
    <tr><td class="paramname">PSA_ERROR_DATA_INVALID</td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__error.html#ga933d40fa2a591004f2e93aa91e11db84">PSA_ERROR_BAD_STATE</a></td><td>The library has not been previously initialized by <a class="el" href="group__initialization.html#ga2de150803fc2f7dc6101d5af7e921dd9" title="Library initialization.">psa_crypto_init()</a>. It is implementation-dependent whether a failure to initialize results in this error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="acrypto__struct_8h_html_a12166ea6ade6825a053b698ed510ef33"><div class="ttname"><a href="crypto__struct_8h.html#a12166ea6ade6825a053b698ed510ef33">psa_sign_hash_interruptible_operation_init</a></div><div class="ttdeci">static struct psa_sign_hash_interruptible_operation_s psa_sign_hash_interruptible_operation_init(void)</div><div class="ttdef"><b>Definition:</b> <a href="crypto__struct_8h_source.html#l00418">crypto_struct.h:418</a></div></div>
<div class="ttc" id="acrypto__struct_8h_html_a570efe3897a9133ffa0373b9984d076c"><div class="ttname"><a href="crypto__struct_8h.html#a570efe3897a9133ffa0373b9984d076c">psa_verify_hash_interruptible_operation_init</a></div><div class="ttdeci">static struct psa_verify_hash_interruptible_operation_s psa_verify_hash_interruptible_operation_init(void)</div><div class="ttdef"><b>Definition:</b> <a href="crypto__struct_8h_source.html#l00448">crypto_struct.h:448</a></div></div>
<div class="ttc" id="acrypto__struct_8h_html_aed5b04a316ca690bd97f5ea0d2b905b9"><div class="ttname"><a href="crypto__struct_8h.html#aed5b04a316ca690bd97f5ea0d2b905b9">PSA_VERIFY_HASH_INTERRUPTIBLE_OPERATION_INIT</a></div><div class="ttdeci">#define PSA_VERIFY_HASH_INTERRUPTIBLE_OPERATION_INIT</div><div class="ttdef"><b>Definition:</b> <a href="crypto__struct_8h_source.html#l00445">crypto_struct.h:445</a></div></div>
<div class="ttc" id="astructpsa__verify__hash__interruptible__operation__s_html"><div class="ttname"><a href="structpsa__verify__hash__interruptible__operation__s.html">psa_verify_hash_interruptible_operation_s</a></div><div class="ttdoc">The context for PSA interruptible hash verification.</div><div class="ttdef"><b>Definition:</b> <a href="crypto__struct_8h_source.html#l00429">crypto_struct.h:429</a></div></div>
<div class="ttc" id="astructpsa__sign__hash__interruptible__operation__s_html"><div class="ttname"><a href="structpsa__sign__hash__interruptible__operation__s.html">psa_sign_hash_interruptible_operation_s</a></div><div class="ttdoc">The context for PSA interruptible hash signing.</div><div class="ttdef"><b>Definition:</b> <a href="crypto__struct_8h_source.html#l00399">crypto_struct.h:399</a></div></div>
<div class="ttc" id="acrypto__struct_8h_html_ae8d7c502f24f810c3abad377daa8b051"><div class="ttname"><a href="crypto__struct_8h.html#ae8d7c502f24f810c3abad377daa8b051">PSA_SIGN_HASH_INTERRUPTIBLE_OPERATION_INIT</a></div><div class="ttdeci">#define PSA_SIGN_HASH_INTERRUPTIBLE_OPERATION_INIT</div><div class="ttdef"><b>Definition:</b> <a href="crypto__struct_8h_source.html#l00415">crypto_struct.h:415</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 6 2024 20:24:42 for Mbed TLS v3.5.1 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
