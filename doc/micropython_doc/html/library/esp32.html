<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>esp32 — functionality specific to the ESP32 &#8212; MicroPython latest documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=def86cc0" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=d5a28fe3" />
    <link rel="stylesheet" href="../_static/customstyle.css" type="text/css" />
    
    <script src="../_static/jquery.js?v=5d32c60e"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../_static/documentation_options.js?v=c6e86fd7"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="espnow — support for the ESP-NOW wireless protocol" href="espnow.html" />
    <link rel="prev" title="esp — functions related to the ESP8266 and ESP32" href="esp.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="espnow.html" title="espnow — support for the ESP-NOW wireless protocol"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="esp.html" title="esp — functions related to the ESP8266 and ESP32"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">MicroPython latest documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">MicroPython libraries</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">esp32</span></code> — functionality specific to the ESP32</a></li> 
      </ul>
    </div>  

    <div class="document">
  
    <div class="wy-alert wy-alert-danger">
      <p>
        This is the documentation for the latest development branch of
        MicroPython and may refer to features that are not available in released
        versions.
      </p>
      <p>
        If you are looking for the documentation for a specific release, use
        the drop-down menu on the left and select the desired version.
      </p>
    </div>
  
  
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-esp32">
<span id="esp32-functionality-specific-to-the-esp32"></span><h1><a class="reference internal" href="#module-esp32" title="esp32: functionality specific to the ESP32"><code class="xref py py-mod docutils literal notranslate"><span class="pre">esp32</span></code></a> — functionality specific to the ESP32<a class="headerlink" href="#module-esp32" title="Link to this heading">¶</a></h1>
<p>The <code class="docutils literal notranslate"><span class="pre">esp32</span></code> module contains functions and classes specifically aimed at
controlling ESP32 modules.</p>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="esp32.wake_on_touch">
<span class="sig-prename descclassname"><span class="pre">esp32.</span></span><span class="sig-name descname"><span class="pre">wake_on_touch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wake</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.wake_on_touch" title="Link to this definition">¶</a></dt>
<dd><p>Configure whether or not a touch will wake the device from sleep.
<em>wake</em> should be a boolean value.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="esp32.wake_on_ulp">
<span class="sig-prename descclassname"><span class="pre">esp32.</span></span><span class="sig-name descname"><span class="pre">wake_on_ulp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wake</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.wake_on_ulp" title="Link to this definition">¶</a></dt>
<dd><p>Configure whether or not the Ultra-Low-Power co-processor can wake the
device from sleep. <em>wake</em> should be a boolean value.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="esp32.wake_on_ext0">
<span class="sig-prename descclassname"><span class="pre">esp32.</span></span><span class="sig-name descname"><span class="pre">wake_on_ext0</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.wake_on_ext0" title="Link to this definition">¶</a></dt>
<dd><p>Configure how EXT0 wakes the device from sleep.  <em>pin</em> can be <code class="docutils literal notranslate"><span class="pre">None</span></code>
or a valid Pin object.  <em>level</em> should be <code class="docutils literal notranslate"><span class="pre">esp32.WAKEUP_ALL_LOW</span></code> or
<code class="docutils literal notranslate"><span class="pre">esp32.WAKEUP_ANY_HIGH</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="esp32.wake_on_ext1">
<span class="sig-prename descclassname"><span class="pre">esp32.</span></span><span class="sig-name descname"><span class="pre">wake_on_ext1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.wake_on_ext1" title="Link to this definition">¶</a></dt>
<dd><p>Configure how EXT1 wakes the device from sleep.  <em>pins</em> can be <code class="docutils literal notranslate"><span class="pre">None</span></code>
or a tuple/list of valid Pin objects.  <em>level</em> should be <code class="docutils literal notranslate"><span class="pre">esp32.WAKEUP_ALL_LOW</span></code>
or <code class="docutils literal notranslate"><span class="pre">esp32.WAKEUP_ANY_HIGH</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="esp32.gpio_deep_sleep_hold">
<span class="sig-prename descclassname"><span class="pre">esp32.</span></span><span class="sig-name descname"><span class="pre">gpio_deep_sleep_hold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">enable</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.gpio_deep_sleep_hold" title="Link to this definition">¶</a></dt>
<dd><p>Configure whether non-RTC GPIO pin configuration is retained during
deep-sleep mode for held pads. <em>enable</em> should be a boolean value.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="esp32.raw_temperature">
<span class="sig-prename descclassname"><span class="pre">esp32.</span></span><span class="sig-name descname"><span class="pre">raw_temperature</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esp32.raw_temperature" title="Link to this definition">¶</a></dt>
<dd><p>Read the raw value of the internal temperature sensor, returning an integer.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="esp32.idf_heap_info">
<span class="sig-prename descclassname"><span class="pre">esp32.</span></span><span class="sig-name descname"><span class="pre">idf_heap_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">capabilities</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.idf_heap_info" title="Link to this definition">¶</a></dt>
<dd><p>Returns information about the ESP-IDF heap memory regions. One of them contains
the MicroPython heap and the others are used by ESP-IDF, e.g., for network
buffers and other data. This data is useful to get a sense of how much memory
is available to ESP-IDF and the networking stack in particular. It may shed
some light on situations where ESP-IDF operations fail due to allocation failures.</p>
<p>The capabilities parameter corresponds to ESP-IDF’s <code class="docutils literal notranslate"><span class="pre">MALLOC_CAP_XXX</span></code> values but the
two most useful ones are predefined as <a class="reference internal" href="#esp32.HEAP_DATA" title="esp32.HEAP_DATA"><code class="xref any py py-data docutils literal notranslate"><span class="pre">esp32.HEAP_DATA</span></code></a> for data heap regions and
<a class="reference internal" href="#esp32.HEAP_EXEC" title="esp32.HEAP_EXEC"><code class="xref any py py-data docutils literal notranslate"><span class="pre">esp32.HEAP_EXEC</span></code></a> for executable regions as used by the native code emitter.</p>
<p>The return value is a list of 4-tuples, where each 4-tuple corresponds to one heap
and contains: the total bytes, the free bytes, the largest free block, and
the minimum free seen over time.</p>
<p>Example after booting:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">esp32</span><span class="p">;</span> <span class="n">esp32</span><span class="o">.</span><span class="n">idf_heap_info</span><span class="p">(</span><span class="n">esp32</span><span class="o">.</span><span class="n">HEAP_DATA</span><span class="p">)</span>
<span class="go">[(240, 0, 0, 0), (7288, 0, 0, 0), (16648, 4, 4, 4), (79912, 35712, 35512, 35108),</span>
<span class="go"> (15072, 15036, 15036, 15036), (113840, 0, 0, 0)]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Free IDF heap memory in the <a class="reference internal" href="#esp32.HEAP_DATA" title="esp32.HEAP_DATA"><code class="xref any py py-data docutils literal notranslate"><span class="pre">esp32.HEAP_DATA</span></code></a> region is available
to be automatically added to the MicroPython heap to prevent a
MicroPython allocation from failing. However, the information returned
here is otherwise <em>not</em> useful to troubleshoot Python allocation
failures. <a class="reference internal" href="micropython.html#micropython.mem_info" title="micropython.mem_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">micropython.mem_info()</span></code></a> and <a class="reference internal" href="gc.html#gc.mem_free" title="gc.mem_free"><code class="xref py py-func docutils literal notranslate"><span class="pre">gc.mem_free()</span></code></a> should
be used instead:</p>
<p>The “max new split” value in <a class="reference internal" href="micropython.html#micropython.mem_info" title="micropython.mem_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">micropython.mem_info()</span></code></a> output
corresponds to the largest free block of ESP-IDF heap that could be
automatically added on demand to the MicroPython heap.</p>
<p>The result of <a class="reference internal" href="gc.html#gc.mem_free" title="gc.mem_free"><code class="xref py py-func docutils literal notranslate"><span class="pre">gc.mem_free()</span></code></a> is the total of the current “free”
and “max new split” values printed by <a class="reference internal" href="micropython.html#micropython.mem_info" title="micropython.mem_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">micropython.mem_info()</span></code></a>.</p>
</div>
</dd></dl>

</section>
<section id="flash-partitions">
<h2>Flash partitions<a class="headerlink" href="#flash-partitions" title="Link to this heading">¶</a></h2>
<p>This class gives access to the partitions in the device’s flash memory and includes
methods to enable over-the-air (OTA) updates.</p>
<dl class="py class">
<dt class="sig sig-object py" id="esp32.Partition">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">esp32.</span></span><span class="sig-name descname"><span class="pre">Partition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4096</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.Partition" title="Link to this definition">¶</a></dt>
<dd><p>Create an object representing a partition.  <em>id</em> can be a string which is the label
of the partition to retrieve, or one of the constants: <code class="docutils literal notranslate"><span class="pre">BOOT</span></code> or <code class="docutils literal notranslate"><span class="pre">RUNNING</span></code>.
<em>block_size</em> specifies the byte size of an individual block.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.Partition.find">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Partition.</span></span><span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">TYPE_APP</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0xff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4096</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.Partition.find" title="Link to this definition">¶</a></dt>
<dd><p>Find a partition specified by <em>type</em>, <em>subtype</em> and <em>label</em>.  Returns a
(possibly empty) list of Partition objects. Note: <code class="docutils literal notranslate"><span class="pre">subtype=0xff</span></code> matches any subtype
and <code class="docutils literal notranslate"><span class="pre">label=None</span></code> matches any label.</p>
<p><em>block_size</em> specifies the byte size of an individual block used by the returned
objects.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.Partition.info">
<span class="sig-prename descclassname"><span class="pre">Partition.</span></span><span class="sig-name descname"><span class="pre">info</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esp32.Partition.info" title="Link to this definition">¶</a></dt>
<dd><p>Returns a 6-tuple <code class="docutils literal notranslate"><span class="pre">(type,</span> <span class="pre">subtype,</span> <span class="pre">addr,</span> <span class="pre">size,</span> <span class="pre">label,</span> <span class="pre">encrypted)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.Partition.readblocks">
<span class="sig-prename descclassname"><span class="pre">Partition.</span></span><span class="sig-name descname"><span class="pre">readblocks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">block_num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.Partition.readblocks" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">Partition.</span></span><span class="sig-name descname"><span class="pre">readblocks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">block_num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.Partition.writeblocks">
<span class="sig-prename descclassname"><span class="pre">Partition.</span></span><span class="sig-name descname"><span class="pre">writeblocks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">block_num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.Partition.writeblocks" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">Partition.</span></span><span class="sig-name descname"><span class="pre">writeblocks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">block_num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.Partition.ioctl">
<span class="sig-prename descclassname"><span class="pre">Partition.</span></span><span class="sig-name descname"><span class="pre">ioctl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cmd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.Partition.ioctl" title="Link to this definition">¶</a></dt>
<dd><p>These methods implement the simple and <a class="reference internal" href="vfs.html#block-device-interface"><span class="std std-ref">extended</span></a> block protocol defined by
<a class="reference internal" href="vfs.html#vfs.AbstractBlockDev" title="vfs.AbstractBlockDev"><code class="xref py py-class docutils literal notranslate"><span class="pre">vfs.AbstractBlockDev</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.Partition.set_boot">
<span class="sig-prename descclassname"><span class="pre">Partition.</span></span><span class="sig-name descname"><span class="pre">set_boot</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esp32.Partition.set_boot" title="Link to this definition">¶</a></dt>
<dd><p>Sets the partition as the boot partition.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Do not enter <a class="reference internal" href="machine.html#machine.deepsleep" title="machine.deepsleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">deepsleep</span></code></a> after changing
the OTA boot partition, without first performing a hard
<a class="reference internal" href="machine.html#machine.reset" title="machine.reset"><code class="xref py py-func docutils literal notranslate"><span class="pre">reset</span></code></a> or power cycle. This ensures the bootloader
will validate the new image before booting.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.Partition.get_next_update">
<span class="sig-prename descclassname"><span class="pre">Partition.</span></span><span class="sig-name descname"><span class="pre">get_next_update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esp32.Partition.get_next_update" title="Link to this definition">¶</a></dt>
<dd><p>Gets the next update partition after this one, and returns a new Partition object.
Typical usage is <code class="docutils literal notranslate"><span class="pre">Partition(Partition.RUNNING).get_next_update()</span></code>
which returns the next partition to update given the current running one.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.Partition.mark_app_valid_cancel_rollback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">Partition.</span></span><span class="sig-name descname"><span class="pre">mark_app_valid_cancel_rollback</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esp32.Partition.mark_app_valid_cancel_rollback" title="Link to this definition">¶</a></dt>
<dd><p>Signals that the current boot is considered successful.
Calling <code class="docutils literal notranslate"><span class="pre">mark_app_valid_cancel_rollback</span></code> is required on the first boot of a new
partition to avoid an automatic rollback at the next boot.
This uses the ESP-IDF “app rollback” feature with “CONFIG_BOOTLOADER_APP_ROLLBACK_ENABLE”
and  an <code class="docutils literal notranslate"><span class="pre">OSError(-261)</span></code> is raised if called on firmware that doesn’t have the
feature enabled.
It is OK to call <code class="docutils literal notranslate"><span class="pre">mark_app_valid_cancel_rollback</span></code> on every boot and it is not
necessary when booting firmware that was loaded using esptool.</p>
</dd></dl>

<section id="constants">
<h3>Constants<a class="headerlink" href="#constants" title="Link to this heading">¶</a></h3>
<dl class="py data">
<dt class="sig sig-object py" id="esp32.Partition.BOOT">
<span class="sig-prename descclassname"><span class="pre">Partition.</span></span><span class="sig-name descname"><span class="pre">BOOT</span></span><a class="headerlink" href="#esp32.Partition.BOOT" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="esp32.Partition.RUNNING">
<span class="sig-prename descclassname"><span class="pre">Partition.</span></span><span class="sig-name descname"><span class="pre">RUNNING</span></span><a class="headerlink" href="#esp32.Partition.RUNNING" title="Link to this definition">¶</a></dt>
<dd><p>Used in the <a class="reference internal" href="#esp32.Partition" title="esp32.Partition"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Partition</span></code></a> constructor to fetch various partitions: <code class="docutils literal notranslate"><span class="pre">BOOT</span></code> is the
partition that will be booted at the next reset and <code class="docutils literal notranslate"><span class="pre">RUNNING</span></code> is the currently
running partition.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="esp32.Partition.TYPE_APP">
<span class="sig-prename descclassname"><span class="pre">Partition.</span></span><span class="sig-name descname"><span class="pre">TYPE_APP</span></span><a class="headerlink" href="#esp32.Partition.TYPE_APP" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="esp32.Partition.TYPE_DATA">
<span class="sig-prename descclassname"><span class="pre">Partition.</span></span><span class="sig-name descname"><span class="pre">TYPE_DATA</span></span><a class="headerlink" href="#esp32.Partition.TYPE_DATA" title="Link to this definition">¶</a></dt>
<dd><p>Used in <a class="reference internal" href="#esp32.Partition.find" title="esp32.Partition.find"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Partition.find</span></code></a> to specify the partition type: <code class="docutils literal notranslate"><span class="pre">APP</span></code> is for bootable
firmware partitions (typically labelled <code class="docutils literal notranslate"><span class="pre">factory</span></code>, <code class="docutils literal notranslate"><span class="pre">ota_0</span></code>, <code class="docutils literal notranslate"><span class="pre">ota_1</span></code>), and
<code class="docutils literal notranslate"><span class="pre">DATA</span></code> is for other partitions, e.g. <code class="docutils literal notranslate"><span class="pre">nvs</span></code>, <code class="docutils literal notranslate"><span class="pre">otadata</span></code>, <code class="docutils literal notranslate"><span class="pre">phy_init</span></code>, <code class="docutils literal notranslate"><span class="pre">vfs</span></code>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="esp32.HEAP_DATA">
<span class="sig-prename descclassname"><span class="pre">esp32.</span></span><span class="sig-name descname"><span class="pre">HEAP_DATA</span></span><a class="headerlink" href="#esp32.HEAP_DATA" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="esp32.HEAP_EXEC">
<span class="sig-prename descclassname"><span class="pre">esp32.</span></span><span class="sig-name descname"><span class="pre">HEAP_EXEC</span></span><a class="headerlink" href="#esp32.HEAP_EXEC" title="Link to this definition">¶</a></dt>
<dd><p>Used in <a class="reference internal" href="#esp32.idf_heap_info" title="esp32.idf_heap_info"><code class="xref any py py-func docutils literal notranslate"><span class="pre">idf_heap_info</span></code></a>.</p>
</dd></dl>

</section>
</section>
<section id="rmt">
<span id="esp32-rmt"></span><h2>RMT<a class="headerlink" href="#rmt" title="Link to this heading">¶</a></h2>
<p>The RMT (Remote Control) module, specific to the ESP32, was originally designed
to send and receive infrared remote control signals. However, due to a flexible
design and very accurate (as low as 12.5ns) pulse generation, it can also be
used to transmit or receive many other types of digital signals:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">esp32</span>
<span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">esp32</span><span class="o">.</span><span class="n">RMT</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pin</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">18</span><span class="p">),</span> <span class="n">clock_div</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">r</span>  <span class="c1"># RMT(channel=0, pin=18, source_freq=80000000, clock_div=8, idle_level=0)</span>

<span class="c1"># To apply a carrier frequency to the high output</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">esp32</span><span class="o">.</span><span class="n">RMT</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pin</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">18</span><span class="p">),</span> <span class="n">clock_div</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">tx_carrier</span><span class="o">=</span><span class="p">(</span><span class="mi">38000</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1"># The channel resolution is 100ns (1/(source_freq/clock_div)).</span>
<span class="n">r</span><span class="o">.</span><span class="n">write_pulses</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Send 0 for 100ns, 1 for 2000ns, 0 for 200ns, 1 for 4000ns</span>
</pre></div>
</div>
<p>The input to the RMT module is an 80MHz clock (in the future it may be able to
configure the input clock but, for now, it’s fixed). <code class="docutils literal notranslate"><span class="pre">clock_div</span></code> <em>divides</em>
the clock input which determines the resolution of the RMT channel. The
numbers specified in <code class="docutils literal notranslate"><span class="pre">write_pulses</span></code> are multiplied by the resolution to
define the pulses.</p>
<p><code class="docutils literal notranslate"><span class="pre">clock_div</span></code> is an 8-bit divider (0-255) and each pulse can be defined by
multiplying the resolution by a 15-bit (1-<code class="docutils literal notranslate"><span class="pre">PULSE_MAX</span></code>) number. There are eight
channels (0-7) and each can have a different clock divider.</p>
<p>So, in the example above, the 80MHz clock is divided by 8. Thus the
resolution is (1/(80Mhz/8)) 100ns. Since the <code class="docutils literal notranslate"><span class="pre">start</span></code> level is 0 and toggles
with each number, the bitstream is <code class="docutils literal notranslate"><span class="pre">0101</span></code> with durations of [100ns, 2000ns,
100ns, 4000ns].</p>
<p>For more details see Espressif’s <a class="reference external" href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/peripherals/rmt.html">ESP-IDF RMT documentation.</a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The current MicroPython RMT implementation lacks some features, most notably
receiving pulses. RMT should be considered a
<em>beta feature</em> and the interface may change in the future.</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="esp32.RMT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">esp32.</span></span><span class="sig-name descname"><span class="pre">RMT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">channel</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clock_div</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idle_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tx_carrier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.RMT" title="Link to this definition">¶</a></dt>
<dd><p>This class provides access to one of the eight RMT channels. <em>channel</em> is
required and identifies which RMT channel (0-7) will be configured. <em>pin</em>,
also required, configures which Pin is bound to the RMT channel. <em>clock_div</em>
is an 8-bit clock divider that divides the source clock (80MHz) to the RMT
channel allowing the resolution to be specified. <em>idle_level</em> specifies
what level the output will be when no transmission is in progress and can
be any value that converts to a boolean, with <code class="docutils literal notranslate"><span class="pre">True</span></code> representing high
voltage and <code class="docutils literal notranslate"><span class="pre">False</span></code> representing low.</p>
<p>To enable the transmission carrier feature, <em>tx_carrier</em> should be a tuple
of three positive integers: carrier frequency, duty percent (<code class="docutils literal notranslate"><span class="pre">0</span></code> to
<code class="docutils literal notranslate"><span class="pre">100</span></code>) and the output level to apply the carrier to (a boolean as per
<em>idle_level</em>).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.RMT.source_freq">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">RMT.</span></span><span class="sig-name descname"><span class="pre">source_freq</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esp32.RMT.source_freq" title="Link to this definition">¶</a></dt>
<dd><p>Returns the source clock frequency. Currently the source clock is not
configurable so this will always return 80MHz.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.RMT.clock_div">
<span class="sig-prename descclassname"><span class="pre">RMT.</span></span><span class="sig-name descname"><span class="pre">clock_div</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esp32.RMT.clock_div" title="Link to this definition">¶</a></dt>
<dd><p>Return the clock divider. Note that the channel resolution is
<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">(source_freq</span> <span class="pre">/</span> <span class="pre">clock_div)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.RMT.wait_done">
<span class="sig-prename descclassname"><span class="pre">RMT.</span></span><span class="sig-name descname"><span class="pre">wait_done</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.RMT.wait_done" title="Link to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the channel is idle or <code class="docutils literal notranslate"><span class="pre">False</span></code> if a sequence of
pulses started with <a class="reference internal" href="#esp32.RMT.write_pulses" title="esp32.RMT.write_pulses"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">RMT.write_pulses</span></code></a> is being transmitted. If the
<em>timeout</em> keyword argument is given then block for up to this many
milliseconds for transmission to complete.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.RMT.loop">
<span class="sig-prename descclassname"><span class="pre">RMT.</span></span><span class="sig-name descname"><span class="pre">loop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">enable_loop</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.RMT.loop" title="Link to this definition">¶</a></dt>
<dd><p>Configure looping on the channel. <em>enable_loop</em> is bool, set to <code class="docutils literal notranslate"><span class="pre">True</span></code> to
enable looping on the <em>next</em> call to <a class="reference internal" href="#esp32.RMT.write_pulses" title="esp32.RMT.write_pulses"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">RMT.write_pulses</span></code></a>. If called with
<code class="docutils literal notranslate"><span class="pre">False</span></code> while a looping sequence is currently being transmitted then the
current loop iteration will be completed and then transmission will stop.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.RMT.write_pulses">
<span class="sig-prename descclassname"><span class="pre">RMT.</span></span><span class="sig-name descname"><span class="pre">write_pulses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">duration</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.RMT.write_pulses" title="Link to this definition">¶</a></dt>
<dd><p>Begin transmitting a sequence. There are three ways to specify this:</p>
<p><strong>Mode 1:</strong> <em>duration</em> is a list or tuple of durations. The optional <em>data</em>
argument specifies the initial output level. The output level will toggle
after each duration.</p>
<p><strong>Mode 2:</strong> <em>duration</em> is a positive integer and <em>data</em> is a list or tuple
of output levels. <em>duration</em> specifies a fixed duration for each.</p>
<p><strong>Mode 3:</strong> <em>duration</em> and <em>data</em> are lists or tuples of equal length,
specifying individual durations and the output level for each.</p>
<p>Durations are in integer units of the channel resolution (as
described above), between 1 and <code class="docutils literal notranslate"><span class="pre">PULSE_MAX</span></code> units. Output levels
are any value that can be converted to a boolean, with <code class="docutils literal notranslate"><span class="pre">True</span></code>
representing high voltage and <code class="docutils literal notranslate"><span class="pre">False</span></code> representing low.</p>
<p>If transmission of an earlier sequence is in progress then this method will
block until that transmission is complete before beginning the new sequence.</p>
<p>If looping has been enabled with <a class="reference internal" href="#esp32.RMT.loop" title="esp32.RMT.loop"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">RMT.loop</span></code></a>, the sequence will be
repeated indefinitely. Further calls to this method will block until the
end of the current loop iteration before immediately beginning to loop the
new sequence of pulses. Looping sequences longer than 126 pulses is not
supported by the hardware.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.RMT.bitstream_channel">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">RMT.</span></span><span class="sig-name descname"><span class="pre">bitstream_channel</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#esp32.RMT.bitstream_channel" title="Link to this definition">¶</a></dt>
<dd><p>Select which RMT channel is used by the <a class="reference internal" href="machine.html#machine.bitstream" title="machine.bitstream"><code class="xref any py py-func docutils literal notranslate"><span class="pre">machine.bitstream</span></code></a> implementation.
<em>value</em> can be <code class="docutils literal notranslate"><span class="pre">None</span></code> or a valid RMT channel number.  The default RMT
channel is the highest numbered one.</p>
<p>Passing in <code class="docutils literal notranslate"><span class="pre">None</span></code> disables the use of RMT and instead selects a bit-banging
implementation for <a class="reference internal" href="machine.html#machine.bitstream" title="machine.bitstream"><code class="xref any py py-func docutils literal notranslate"><span class="pre">machine.bitstream</span></code></a>.</p>
<p>Passing in no argument will not change the channel.  This function returns
the current channel number.</p>
</dd></dl>

</section>
<section id="id1">
<h2>Constants<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h2>
<dl class="py data">
<dt class="sig sig-object py" id="esp32.RMT.PULSE_MAX">
<span class="sig-prename descclassname"><span class="pre">RMT.</span></span><span class="sig-name descname"><span class="pre">PULSE_MAX</span></span><a class="headerlink" href="#esp32.RMT.PULSE_MAX" title="Link to this definition">¶</a></dt>
<dd><p>Maximum integer that can be set for a pulse duration.</p>
</dd></dl>

</section>
<section id="ultra-low-power-co-processor">
<h2>Ultra-Low-Power co-processor<a class="headerlink" href="#ultra-low-power-co-processor" title="Link to this heading">¶</a></h2>
<p>This class gives access to the Ultra Low Power (ULP) co-processor on the ESP32,
ESP32-S2 and ESP32-S3 chips.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This class does not provide access to the RISCV ULP co-processor available
on the ESP32-S2 and ESP32-S3 chips.</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="esp32.ULP">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">esp32.</span></span><span class="sig-name descname"><span class="pre">ULP</span></span><a class="headerlink" href="#esp32.ULP" title="Link to this definition">¶</a></dt>
<dd><p>This class provides access to the Ultra-Low-Power co-processor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.ULP.set_wakeup_period">
<span class="sig-prename descclassname"><span class="pre">ULP.</span></span><span class="sig-name descname"><span class="pre">set_wakeup_period</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">period_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">period_us</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.ULP.set_wakeup_period" title="Link to this definition">¶</a></dt>
<dd><p>Set the wake-up period.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.ULP.load_binary">
<span class="sig-prename descclassname"><span class="pre">ULP.</span></span><span class="sig-name descname"><span class="pre">load_binary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">load_addr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">program_binary</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.ULP.load_binary" title="Link to this definition">¶</a></dt>
<dd><p>Load a <em>program_binary</em> into the ULP at the given <em>load_addr</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.ULP.run">
<span class="sig-prename descclassname"><span class="pre">ULP.</span></span><span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">entry_point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.ULP.run" title="Link to this definition">¶</a></dt>
<dd><p>Start the ULP running at the given <em>entry_point</em>.</p>
</dd></dl>

</section>
<section id="id2">
<h2>Constants<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h2>
<dl class="py data">
<dt class="sig sig-object py" id="esp32.esp32.WAKEUP_ALL_LOW">
<span class="sig-prename descclassname"><span class="pre">esp32.</span></span><span class="sig-name descname"><span class="pre">WAKEUP_ALL_LOW</span></span><a class="headerlink" href="#esp32.esp32.WAKEUP_ALL_LOW" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="esp32.esp32.WAKEUP_ANY_HIGH">
<span class="sig-prename descclassname"><span class="pre">esp32.</span></span><span class="sig-name descname"><span class="pre">WAKEUP_ANY_HIGH</span></span><a class="headerlink" href="#esp32.esp32.WAKEUP_ANY_HIGH" title="Link to this definition">¶</a></dt>
<dd><p>Selects the wake level for pins.</p>
</dd></dl>

</section>
<section id="non-volatile-storage">
<h2>Non-Volatile Storage<a class="headerlink" href="#non-volatile-storage" title="Link to this heading">¶</a></h2>
<p>This class gives access to the Non-Volatile storage managed by ESP-IDF. The NVS is partitioned
into namespaces and each namespace contains typed key-value pairs. The keys are strings and the
values may be various integer types, strings, and binary blobs. The driver currently only
supports 32-bit signed integers and blobs.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Changes to NVS need to be committed to flash by calling the commit method. Failure
to call commit results in changes being lost at the next reset.</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="esp32.NVS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">esp32.</span></span><span class="sig-name descname"><span class="pre">NVS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">namespace</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.NVS" title="Link to this definition">¶</a></dt>
<dd><p>Create an object providing access to a namespace (which is automatically created if not
present).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.NVS.set_i32">
<span class="sig-prename descclassname"><span class="pre">NVS.</span></span><span class="sig-name descname"><span class="pre">set_i32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.NVS.set_i32" title="Link to this definition">¶</a></dt>
<dd><p>Sets a 32-bit signed integer value for the specified key. Remember to call <em>commit</em>!</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.NVS.get_i32">
<span class="sig-prename descclassname"><span class="pre">NVS.</span></span><span class="sig-name descname"><span class="pre">get_i32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.NVS.get_i32" title="Link to this definition">¶</a></dt>
<dd><p>Returns the signed integer value for the specified key. Raises an OSError if the key does not
exist or has a different type.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.NVS.set_blob">
<span class="sig-prename descclassname"><span class="pre">NVS.</span></span><span class="sig-name descname"><span class="pre">set_blob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.NVS.set_blob" title="Link to this definition">¶</a></dt>
<dd><p>Sets a binary blob value for the specified key. The value passed in must support the buffer
protocol, e.g. bytes, bytearray, str. (Note that esp-idf distinguishes blobs and strings, this
method always writes a blob even if a string is passed in as value.)
Remember to call <em>commit</em>!</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.NVS.get_blob">
<span class="sig-prename descclassname"><span class="pre">NVS.</span></span><span class="sig-name descname"><span class="pre">get_blob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.NVS.get_blob" title="Link to this definition">¶</a></dt>
<dd><p>Reads the value of the blob for the specified key into the buffer, which must be a bytearray.
Returns the actual length read. Raises an OSError if the key does not exist, has a different
type, or if the buffer is too small.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.NVS.erase_key">
<span class="sig-prename descclassname"><span class="pre">NVS.</span></span><span class="sig-name descname"><span class="pre">erase_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#esp32.NVS.erase_key" title="Link to this definition">¶</a></dt>
<dd><p>Erases a key-value pair.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="esp32.NVS.commit">
<span class="sig-prename descclassname"><span class="pre">NVS.</span></span><span class="sig-name descname"><span class="pre">commit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esp32.NVS.commit" title="Link to this definition">¶</a></dt>
<dd><p>Commits changes made by <em>set_xxx</em> methods to flash.</p>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>

      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">esp32</span></code> — functionality specific to the ESP32</a><ul>
<li><a class="reference internal" href="#functions">Functions</a><ul>
<li><a class="reference internal" href="#esp32.wake_on_touch"><code class="docutils literal notranslate"><span class="pre">wake_on_touch()</span></code></a></li>
<li><a class="reference internal" href="#esp32.wake_on_ulp"><code class="docutils literal notranslate"><span class="pre">wake_on_ulp()</span></code></a></li>
<li><a class="reference internal" href="#esp32.wake_on_ext0"><code class="docutils literal notranslate"><span class="pre">wake_on_ext0()</span></code></a></li>
<li><a class="reference internal" href="#esp32.wake_on_ext1"><code class="docutils literal notranslate"><span class="pre">wake_on_ext1()</span></code></a></li>
<li><a class="reference internal" href="#esp32.gpio_deep_sleep_hold"><code class="docutils literal notranslate"><span class="pre">gpio_deep_sleep_hold()</span></code></a></li>
<li><a class="reference internal" href="#esp32.raw_temperature"><code class="docutils literal notranslate"><span class="pre">raw_temperature()</span></code></a></li>
<li><a class="reference internal" href="#esp32.idf_heap_info"><code class="docutils literal notranslate"><span class="pre">idf_heap_info()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#flash-partitions">Flash partitions</a><ul>
<li><a class="reference internal" href="#esp32.Partition"><code class="docutils literal notranslate"><span class="pre">Partition</span></code></a></li>
<li><a class="reference internal" href="#esp32.Partition.find"><code class="docutils literal notranslate"><span class="pre">Partition.find()</span></code></a></li>
<li><a class="reference internal" href="#esp32.Partition.info"><code class="docutils literal notranslate"><span class="pre">Partition.info()</span></code></a></li>
<li><a class="reference internal" href="#esp32.Partition.readblocks"><code class="docutils literal notranslate"><span class="pre">Partition.readblocks()</span></code></a></li>
<li><a class="reference internal" href="#esp32.Partition.writeblocks"><code class="docutils literal notranslate"><span class="pre">Partition.writeblocks()</span></code></a></li>
<li><a class="reference internal" href="#esp32.Partition.ioctl"><code class="docutils literal notranslate"><span class="pre">Partition.ioctl()</span></code></a></li>
<li><a class="reference internal" href="#esp32.Partition.set_boot"><code class="docutils literal notranslate"><span class="pre">Partition.set_boot()</span></code></a></li>
<li><a class="reference internal" href="#esp32.Partition.get_next_update"><code class="docutils literal notranslate"><span class="pre">Partition.get_next_update()</span></code></a></li>
<li><a class="reference internal" href="#esp32.Partition.mark_app_valid_cancel_rollback"><code class="docutils literal notranslate"><span class="pre">Partition.mark_app_valid_cancel_rollback()</span></code></a></li>
<li><a class="reference internal" href="#constants">Constants</a><ul>
<li><a class="reference internal" href="#esp32.Partition.BOOT"><code class="docutils literal notranslate"><span class="pre">Partition.BOOT</span></code></a></li>
<li><a class="reference internal" href="#esp32.Partition.RUNNING"><code class="docutils literal notranslate"><span class="pre">Partition.RUNNING</span></code></a></li>
<li><a class="reference internal" href="#esp32.Partition.TYPE_APP"><code class="docutils literal notranslate"><span class="pre">Partition.TYPE_APP</span></code></a></li>
<li><a class="reference internal" href="#esp32.Partition.TYPE_DATA"><code class="docutils literal notranslate"><span class="pre">Partition.TYPE_DATA</span></code></a></li>
<li><a class="reference internal" href="#esp32.HEAP_DATA"><code class="docutils literal notranslate"><span class="pre">HEAP_DATA</span></code></a></li>
<li><a class="reference internal" href="#esp32.HEAP_EXEC"><code class="docutils literal notranslate"><span class="pre">HEAP_EXEC</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#rmt">RMT</a><ul>
<li><a class="reference internal" href="#esp32.RMT"><code class="docutils literal notranslate"><span class="pre">RMT</span></code></a></li>
<li><a class="reference internal" href="#esp32.RMT.source_freq"><code class="docutils literal notranslate"><span class="pre">RMT.source_freq()</span></code></a></li>
<li><a class="reference internal" href="#esp32.RMT.clock_div"><code class="docutils literal notranslate"><span class="pre">RMT.clock_div()</span></code></a></li>
<li><a class="reference internal" href="#esp32.RMT.wait_done"><code class="docutils literal notranslate"><span class="pre">RMT.wait_done()</span></code></a></li>
<li><a class="reference internal" href="#esp32.RMT.loop"><code class="docutils literal notranslate"><span class="pre">RMT.loop()</span></code></a></li>
<li><a class="reference internal" href="#esp32.RMT.write_pulses"><code class="docutils literal notranslate"><span class="pre">RMT.write_pulses()</span></code></a></li>
<li><a class="reference internal" href="#esp32.RMT.bitstream_channel"><code class="docutils literal notranslate"><span class="pre">RMT.bitstream_channel()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id1">Constants</a><ul>
<li><a class="reference internal" href="#esp32.RMT.PULSE_MAX"><code class="docutils literal notranslate"><span class="pre">RMT.PULSE_MAX</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#ultra-low-power-co-processor">Ultra-Low-Power co-processor</a><ul>
<li><a class="reference internal" href="#esp32.ULP"><code class="docutils literal notranslate"><span class="pre">ULP</span></code></a></li>
<li><a class="reference internal" href="#esp32.ULP.set_wakeup_period"><code class="docutils literal notranslate"><span class="pre">ULP.set_wakeup_period()</span></code></a></li>
<li><a class="reference internal" href="#esp32.ULP.load_binary"><code class="docutils literal notranslate"><span class="pre">ULP.load_binary()</span></code></a></li>
<li><a class="reference internal" href="#esp32.ULP.run"><code class="docutils literal notranslate"><span class="pre">ULP.run()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id2">Constants</a><ul>
<li><a class="reference internal" href="#esp32.esp32.WAKEUP_ALL_LOW"><code class="docutils literal notranslate"><span class="pre">esp32.WAKEUP_ALL_LOW</span></code></a></li>
<li><a class="reference internal" href="#esp32.esp32.WAKEUP_ANY_HIGH"><code class="docutils literal notranslate"><span class="pre">esp32.WAKEUP_ANY_HIGH</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#non-volatile-storage">Non-Volatile Storage</a><ul>
<li><a class="reference internal" href="#esp32.NVS"><code class="docutils literal notranslate"><span class="pre">NVS</span></code></a></li>
<li><a class="reference internal" href="#esp32.NVS.set_i32"><code class="docutils literal notranslate"><span class="pre">NVS.set_i32()</span></code></a></li>
<li><a class="reference internal" href="#esp32.NVS.get_i32"><code class="docutils literal notranslate"><span class="pre">NVS.get_i32()</span></code></a></li>
<li><a class="reference internal" href="#esp32.NVS.set_blob"><code class="docutils literal notranslate"><span class="pre">NVS.set_blob()</span></code></a></li>
<li><a class="reference internal" href="#esp32.NVS.get_blob"><code class="docutils literal notranslate"><span class="pre">NVS.get_blob()</span></code></a></li>
<li><a class="reference internal" href="#esp32.NVS.erase_key"><code class="docutils literal notranslate"><span class="pre">NVS.erase_key()</span></code></a></li>
<li><a class="reference internal" href="#esp32.NVS.commit"><code class="docutils literal notranslate"><span class="pre">NVS.commit()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="esp.html"
                          title="previous chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">esp</span></code> — functions related to the ESP8266 and ESP32</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="espnow.html"
                          title="next chapter"><code class="xref py py-mod docutils literal notranslate"><span class="pre">espnow</span></code> — support for the ESP-NOW wireless protocol</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/library/esp32.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="espnow.html" title="espnow — support for the ESP-NOW wireless protocol"
             >next</a> |</li>
        <li class="right" >
          <a href="esp.html" title="esp — functions related to the ESP8266 and ESP32"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">MicroPython latest documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >MicroPython libraries</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">esp32</span></code> — functionality specific to the ESP32</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright - The MicroPython Documentation is Copyright © 2014-2024, Damien P. George, Paul Sokolovsky, and contributors.
      Last updated on 24 Jul 2024.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.7.
    </div>
  </body>
</html>