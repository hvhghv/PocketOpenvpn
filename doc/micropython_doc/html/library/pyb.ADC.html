<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>class ADC – analog to digital conversion &#8212; MicroPython latest documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=def86cc0" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=d5a28fe3" />
    <link rel="stylesheet" href="../_static/customstyle.css" type="text/css" />
    
    <script src="../_static/jquery.js?v=5d32c60e"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../_static/documentation_options.js?v=c6e86fd7"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="class CAN – controller area network communication bus" href="pyb.CAN.html" />
    <link rel="prev" title="class Accel – accelerometer control" href="pyb.Accel.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyb.CAN.html" title="class CAN – controller area network communication bus"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pyb.Accel.html" title="class Accel – accelerometer control"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">MicroPython latest documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >MicroPython libraries</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="pyb.html" accesskey="U"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyb</span></code> — functions related to the board</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">class ADC – analog to digital conversion</a></li> 
      </ul>
    </div>  

    <div class="document">
  
    <div class="wy-alert wy-alert-danger">
      <p>
        This is the documentation for the latest development branch of
        MicroPython and may refer to features that are not available in released
        versions.
      </p>
      <p>
        If you are looking for the documentation for a specific release, use
        the drop-down menu on the left and select the desired version.
      </p>
    </div>
  
  
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="class-adc-analog-to-digital-conversion">
<span id="pyb-adc"></span><h1>class ADC – analog to digital conversion<a class="headerlink" href="#class-adc-analog-to-digital-conversion" title="Link to this heading">¶</a></h1>
<p>Usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyb</span>

<span class="n">adc</span> <span class="o">=</span> <span class="n">pyb</span><span class="o">.</span><span class="n">ADC</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>                  <span class="c1"># create an analog object from a pin</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">adc</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>                    <span class="c1"># read an analog value</span>

<span class="n">adc</span> <span class="o">=</span> <span class="n">pyb</span><span class="o">.</span><span class="n">ADCAll</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span>        <span class="c1"># create an ADCAll object</span>
<span class="n">adc</span> <span class="o">=</span> <span class="n">pyb</span><span class="o">.</span><span class="n">ADCAll</span><span class="p">(</span><span class="n">resolution</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>  <span class="c1"># create an ADCAll object for selected analog channels</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">adc</span><span class="o">.</span><span class="n">read_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>     <span class="c1"># read the given channel</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">adc</span><span class="o">.</span><span class="n">read_core_temp</span><span class="p">()</span>          <span class="c1"># read MCU temperature</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">adc</span><span class="o">.</span><span class="n">read_core_vbat</span><span class="p">()</span>          <span class="c1"># read MCU VBAT</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">adc</span><span class="o">.</span><span class="n">read_core_vref</span><span class="p">()</span>          <span class="c1"># read MCU VREF</span>
<span class="n">val</span> <span class="o">=</span> <span class="n">adc</span><span class="o">.</span><span class="n">read_vref</span><span class="p">()</span>               <span class="c1"># read MCU supply voltage</span>
</pre></div>
</div>
<section id="constructors">
<h2>Constructors<a class="headerlink" href="#constructors" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pyb.ADC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyb.</span></span><span class="sig-name descname"><span class="pre">ADC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pin</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyb.ADC" title="Link to this definition">¶</a></dt>
<dd><p>Create an ADC object associated with the given pin.
This allows you to then read analog values on that pin.</p>
</dd></dl>

</section>
<section id="methods">
<h2>Methods<a class="headerlink" href="#methods" title="Link to this heading">¶</a></h2>
<dl class="py method">
<dt class="sig sig-object py" id="pyb.ADC.read">
<span class="sig-prename descclassname"><span class="pre">ADC.</span></span><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyb.ADC.read" title="Link to this definition">¶</a></dt>
<dd><p>Read the value on the analog pin and return it.  The returned value
will be between 0 and 4095.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyb.ADC.read_timed">
<span class="sig-prename descclassname"><span class="pre">ADC.</span></span><span class="sig-name descname"><span class="pre">read_timed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyb.ADC.read_timed" title="Link to this definition">¶</a></dt>
<dd><p>Read analog values into <code class="docutils literal notranslate"><span class="pre">buf</span></code> at a rate set by the <code class="docutils literal notranslate"><span class="pre">timer</span></code> object.</p>
<p><code class="docutils literal notranslate"><span class="pre">buf</span></code> can be bytearray or array.array for example.  The ADC values have
12-bit resolution and are stored directly into <code class="docutils literal notranslate"><span class="pre">buf</span></code> if its element size is
16 bits or greater.  If <code class="docutils literal notranslate"><span class="pre">buf</span></code> has only 8-bit elements (eg a bytearray) then
the sample resolution will be reduced to 8 bits.</p>
<p><code class="docutils literal notranslate"><span class="pre">timer</span></code> should be a Timer object, and a sample is read each time the timer
triggers.  The timer must already be initialised and running at the desired
sampling frequency.</p>
<p>To support previous behaviour of this function, <code class="docutils literal notranslate"><span class="pre">timer</span></code> can also be an
integer which specifies the frequency (in Hz) to sample at.  In this case
Timer(6) will be automatically configured to run at the given frequency.</p>
<p>Example using a Timer object (preferred way):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">adc</span> <span class="o">=</span> <span class="n">pyb</span><span class="o">.</span><span class="n">ADC</span><span class="p">(</span><span class="n">pyb</span><span class="o">.</span><span class="n">Pin</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">X19</span><span class="p">)</span>    <span class="c1"># create an ADC on pin X19</span>
<span class="n">tim</span> <span class="o">=</span> <span class="n">pyb</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>         <span class="c1"># create a timer running at 10Hz</span>
<span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>                <span class="c1"># creat a buffer to store the samples</span>
<span class="n">adc</span><span class="o">.</span><span class="n">read_timed</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">tim</span><span class="p">)</span>            <span class="c1"># sample 100 values, taking 10s</span>
</pre></div>
</div>
<p>Example using an integer for the frequency:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">adc</span> <span class="o">=</span> <span class="n">pyb</span><span class="o">.</span><span class="n">ADC</span><span class="p">(</span><span class="n">pyb</span><span class="o">.</span><span class="n">Pin</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">X19</span><span class="p">)</span>    <span class="c1"># create an ADC on pin X19</span>
<span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>                <span class="c1"># create a buffer of 100 bytes</span>
<span class="n">adc</span><span class="o">.</span><span class="n">read_timed</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>             <span class="c1"># read analog values into buf at 10Hz</span>
                                    <span class="c1">#   this will take 10 seconds to finish</span>
<span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">buf</span><span class="p">:</span>                     <span class="c1"># loop over all values</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>                      <span class="c1"># print the value out</span>
</pre></div>
</div>
<p>This function does not allocate any heap memory. It has blocking behaviour:
it does not return to the calling program until the buffer is full.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyb.ADC.read_timed_multi">
<span class="sig-prename descclassname"><span class="pre">ADC.</span></span><span class="sig-name descname"><span class="pre">read_timed_multi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">(adcx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adcy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">...)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">(bufx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bufy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">...)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyb.ADC.read_timed_multi" title="Link to this definition">¶</a></dt>
<dd><p>This is a static method. It can be used to extract relative timing or
phase data from multiple ADC’s.</p>
<p>It reads analog values from multiple ADC’s into buffers at a rate set by
the <em>timer</em> object. Each time the timer triggers a sample is rapidly
read from each ADC in turn.</p>
<p>ADC and buffer instances are passed in tuples with each ADC having an
associated buffer. All buffers must be of the same type and length and
the number of buffers must equal the number of ADC’s.</p>
<p>Buffers can be <code class="docutils literal notranslate"><span class="pre">bytearray</span></code> or <code class="docutils literal notranslate"><span class="pre">array.array</span></code> for example. The ADC values
have 12-bit resolution and are stored directly into the buffer if its element
size is 16 bits or greater.  If buffers have only 8-bit elements (eg a
<code class="docutils literal notranslate"><span class="pre">bytearray</span></code>) then the sample resolution will be reduced to 8 bits.</p>
<p><em>timer</em> must be a Timer object. The timer must already be initialised
and running at the desired sampling frequency.</p>
<p>Example reading 3 ADC’s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">adc0</span> <span class="o">=</span> <span class="n">pyb</span><span class="o">.</span><span class="n">ADC</span><span class="p">(</span><span class="n">pyb</span><span class="o">.</span><span class="n">Pin</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">X1</span><span class="p">)</span>    <span class="c1"># Create ADC&#39;s</span>
<span class="n">adc1</span> <span class="o">=</span> <span class="n">pyb</span><span class="o">.</span><span class="n">ADC</span><span class="p">(</span><span class="n">pyb</span><span class="o">.</span><span class="n">Pin</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">X2</span><span class="p">)</span>
<span class="n">adc2</span> <span class="o">=</span> <span class="n">pyb</span><span class="o">.</span><span class="n">ADC</span><span class="p">(</span><span class="n">pyb</span><span class="o">.</span><span class="n">Pin</span><span class="o">.</span><span class="n">board</span><span class="o">.</span><span class="n">X3</span><span class="p">)</span>
<span class="n">tim</span> <span class="o">=</span> <span class="n">pyb</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>        <span class="c1"># Create timer</span>
<span class="n">rx0</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)))</span> <span class="c1"># ADC buffers of</span>
<span class="n">rx1</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)))</span> <span class="c1"># 100 16-bit words</span>
<span class="n">rx2</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)))</span>
<span class="c1"># read analog values into buffers at 100Hz (takes one second)</span>
<span class="n">pyb</span><span class="o">.</span><span class="n">ADC</span><span class="o">.</span><span class="n">read_timed_multi</span><span class="p">((</span><span class="n">adc0</span><span class="p">,</span> <span class="n">adc1</span><span class="p">,</span> <span class="n">adc2</span><span class="p">),</span> <span class="p">(</span><span class="n">rx0</span><span class="p">,</span> <span class="n">rx1</span><span class="p">,</span> <span class="n">rx2</span><span class="p">),</span> <span class="n">tim</span><span class="p">)</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rx0</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">rx0</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">rx1</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">rx2</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
</pre></div>
</div>
<p>This function does not allocate any heap memory. It has blocking behaviour:
it does not return to the calling program until the buffers are full.</p>
<p>The function returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if all samples were acquired with correct
timing. At high sample rates the time taken to acquire a set of samples
can exceed the timer period. In this case the function returns <code class="docutils literal notranslate"><span class="pre">False</span></code>,
indicating a loss of precision in the sample interval. In extreme cases
samples may be missed.</p>
<p>The maximum rate depends on factors including the data width and the
number of ADC’s being read. In testing two ADC’s were sampled at a timer
rate of 210kHz without overrun. Samples were missed at 215kHz.  For three
ADC’s the limit is around 140kHz, and for four it is around 110kHz.
At high sample rates disabling interrupts for the duration can reduce the
risk of sporadic data loss.</p>
</dd></dl>

</section>
<section id="the-adcall-object">
<h2>The ADCAll Object<a class="headerlink" href="#the-adcall-object" title="Link to this heading">¶</a></h2>
<p>Instantiating this changes all masked ADC pins to analog inputs. The preprocessed MCU temperature,
VREF and VBAT data can be accessed on ADC channels 16, 17 and 18 respectively.
Appropriate scaling is handled according to reference voltage used (usually 3.3V).
The temperature sensor on the chip is factory calibrated and allows to read the die temperature
to +/- 1 degree centigrade. Although this sounds pretty accurate, don’t forget that the MCU’s internal
temperature is measured. Depending on processing loads and I/O subsystems active the die temperature
may easily be tens of degrees above ambient temperature. On the other hand a pyboard woken up after a
long standby period will show correct ambient temperature within limits mentioned above.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ADCAll</span></code> <code class="docutils literal notranslate"><span class="pre">read_core_vbat()</span></code>, <code class="docutils literal notranslate"><span class="pre">read_vref()</span></code> and <code class="docutils literal notranslate"><span class="pre">read_core_vref()</span></code> methods read
the backup battery voltage, reference voltage and the (1.21V nominal) reference voltage using the
actual supply as a reference. All results are floating point numbers giving direct voltage values.</p>
<p><code class="docutils literal notranslate"><span class="pre">read_core_vbat()</span></code> returns the voltage of the backup battery. This voltage is also adjusted according
to the actual supply voltage. To avoid analog input overload the battery voltage is measured
via a voltage divider and scaled according to the divider value. To prevent excessive loads
to the backup battery, the voltage divider is only active during ADC conversion.</p>
<p><code class="docutils literal notranslate"><span class="pre">read_vref()</span></code> is evaluated by measuring the internal voltage reference and backscale it using
factory calibration value of the internal voltage reference. In most cases the reading would be close
to 3.3V. If the pyboard is operated from a battery, the supply voltage may drop to values below 3.3V.
The pyboard will still operate fine as long as the operating conditions are met. With proper settings
of MCU clock, flash access speed and programming mode it is possible to run the pyboard down to
2 V and still get useful ADC conversion.</p>
<p>It is very important to make sure analog input voltages never exceed actual supply voltage.</p>
<p>Other analog input channels (0..15) will return unscaled integer values according to the selected
precision.</p>
<p>To avoid unwanted activation of analog inputs (channel 0..15) a second parameter can be specified.
This parameter is a binary pattern where each requested analog input has the corresponding bit set.
The default value is 0xffffffff which means all analog inputs are active. If just the internal
channels (16..18) are required, the mask value should be 0x70000.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">adcall</span> <span class="o">=</span> <span class="n">pyb</span><span class="o">.</span><span class="n">ADCAll</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mh">0x70000</span><span class="p">)</span> <span class="c1"># 12 bit resolution, internal channels</span>
<span class="n">temp</span> <span class="o">=</span> <span class="n">adcall</span><span class="o">.</span><span class="n">read_core_temp</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>

      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">class ADC – analog to digital conversion</a><ul>
<li><a class="reference internal" href="#constructors">Constructors</a><ul>
<li><a class="reference internal" href="#pyb.ADC"><code class="docutils literal notranslate"><span class="pre">ADC</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#methods">Methods</a><ul>
<li><a class="reference internal" href="#pyb.ADC.read"><code class="docutils literal notranslate"><span class="pre">ADC.read()</span></code></a></li>
<li><a class="reference internal" href="#pyb.ADC.read_timed"><code class="docutils literal notranslate"><span class="pre">ADC.read_timed()</span></code></a></li>
<li><a class="reference internal" href="#pyb.ADC.read_timed_multi"><code class="docutils literal notranslate"><span class="pre">ADC.read_timed_multi()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-adcall-object">The ADCAll Object</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="pyb.Accel.html"
                          title="previous chapter">class Accel – accelerometer control</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="pyb.CAN.html"
                          title="next chapter">class CAN – controller area network communication bus</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/library/pyb.ADC.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyb.CAN.html" title="class CAN – controller area network communication bus"
             >next</a> |</li>
        <li class="right" >
          <a href="pyb.Accel.html" title="class Accel – accelerometer control"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">MicroPython latest documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >MicroPython libraries</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="pyb.html" ><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyb</span></code> — functions related to the board</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">class ADC – analog to digital conversion</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright - The MicroPython Documentation is Copyright © 2014-2024, Damien P. George, Paul Sokolovsky, and contributors.
      Last updated on 24 Jul 2024.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.7.
    </div>
  </body>
</html>